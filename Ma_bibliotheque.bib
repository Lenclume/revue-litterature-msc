
@misc{parol_p4_2020,
	title = {P4 {Network} {Programming} {Language}—what is it all about?},
	url = {https://codilime.com/blog/p4-network-programming-language-what-is-it-all-about/},
	abstract = {P4 is a programming language that can be used to program network devices. Read on to learn more on its history, architecture and use cases.},
	language = {en-us},
	urldate = {2023-01-18},
	journal = {CodiLime},
	author = {Parol, Pawel},
	month = apr,
	year = {2020},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\4JMF8XCM\\p4-network-programming-language-what-is-it-all-about.html:text/html},
}

@misc{noauthor_what_2022,
	title = {What you should know about {P4} programming language\& {P4} programmable switch},
	url = {https://cloudswit.ch/blogs/what-you-should-know-about-p4-programming-language-p4-switch/},
	abstract = {This article is an explanation of what is P4 programming language\& P4 switch. Further introduces Asterfusion Tofino based 3.3T-6.5T P4 programmable switch solutions},
	language = {en-US},
	urldate = {2023-01-18},
	journal = {Open Source Software Defined Network},
	month = jan,
	year = {2022},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\KL9P32VV\\what-you-should-know-about-p4-programming-language-p4-switch.html:text/html},
}

@misc{rijsman_getting_2019,
	title = {Getting {Started} with {P4}},
	url = {https://opennetworking.org/news-and-events/blog/getting-started-with-p4/},
	abstract = {Editor Note: This post was originally written by Bruno Rijsman for his personal blog. We are re-publishing it here (with permission) as it provides an excellent introduction to getting started with the P4 language using the software tools that have been developed by the open-source community. Introduction I recently got serious about learning P4, a […]},
	language = {en-US},
	urldate = {2023-01-18},
	journal = {Open Networking Foundation},
	author = {Rijsman, Bruno},
	month = oct,
	year = {2019},
	keywords = {Lu, Tutoriel},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\KE2ZQHAN\\getting-started-with-p4.html:text/html},
}

@article{bosshart_p4_2014,
	title = {P4: programming protocol-independent packet processors},
	volume = {44},
	issn = {0146-4833},
	shorttitle = {P4},
	url = {https://dl.acm.org/doi/10.1145/2656877.2656890},
	doi = {10.1145/2656877.2656890},
	abstract = {P4 is a high-level language for programming protocol-independent packet processors. P4 works in conjunction with SDN control protocols like OpenFlow. In its current form, OpenFlow explicitly speciﬁes protocol headers on which it operates. This set has grown from 12 to 41 ﬁelds in a few years, increasing the complexity of the speciﬁcation while still not providing the ﬂexibility to add new headers. In this paper we propose P4 as a strawman proposal for how OpenFlow should evolve in the future. We have three goals: (1) Reconﬁgurability in the ﬁeld: Programmers should be able to change the way switches process packets once they are deployed. (2) Protocol independence: Switches should not be tied to any speciﬁc network protocols. (3) Target independence: Programmers should be able to describe packetprocessing functionality independently of the speciﬁcs of the underlying hardware. As an example, we describe how to use P4 to conﬁgure a switch to add a new hierarchical label.},
	language = {en},
	number = {3},
	urldate = {2023-01-24},
	journal = {ACM SIGCOMM Computer Communication Review},
	author = {Bosshart, Pat and Daly, Dan and Gibb, Glen and Izzard, Martin and McKeown, Nick and Rexford, Jennifer and Schlesinger, Cole and Talayco, Dan and Vahdat, Amin and Varghese, George and Walker, David},
	month = jul,
	year = {2014},
	keywords = {Lu},
	pages = {87--95},
	file = {Bosshart et al. - 2014 - P4 programming protocol-independent packet proces.pdf:C\:\\Users\\Yann\\Zotero\\storage\\K7B89BDF\\Bosshart et al. - 2014 - P4 programming protocol-independent packet proces.pdf:application/pdf},
}

@article{michel_programmable_2022,
	title = {The {Programmable} {Data} {Plane}: {Abstractions}, {Architectures}, {Algorithms}, and {Applications}},
	volume = {54},
	issn = {0360-0300, 1557-7341},
	shorttitle = {The {Programmable} {Data} {Plane}},
	url = {http://arxiv.org/abs/2110.00631},
	doi = {10.1145/3447868},
	abstract = {Programmable data plane technology enables the systematic reconfiguration of the low-level processing steps applied to network packets and is a key driver in realizing the next generation of network services and applications. This survey presents recent trends and issues in the design and implementation of programmable network devices, focusing on prominent architectures, abstractions, algorithms, and applications proposed, debated, and realized over the past years. We elaborate on the trends that led to the emergence of this technology and highlight the most important pointers from the literature, casting different taxonomies for the field and identifying avenues for future research.},
	language = {en},
	number = {4},
	urldate = {2023-01-24},
	journal = {ACM Computing Surveys},
	author = {Michel, Oliver and Bifulco, Roberto and Retvari, Gabor and Schmid, Stefan},
	month = may,
	year = {2022},
	note = {arXiv:2110.00631 [cs]},
	keywords = {Computer Science - Networking and Internet Architecture},
	pages = {1--36},
	file = {Michel et al. - 2022 - The Programmable Data Plane Abstractions, Archite.pdf:C\:\\Users\\Yann\\Zotero\\storage\\6AIVRSXF\\Michel et al. - 2022 - The Programmable Data Plane Abstractions, Archite.pdf:application/pdf},
}

@article{kfoury_exhaustive_2021,
	title = {An {Exhaustive} {Survey} on {P4} {Programmable} {Data} {Plane} {Switches}: {Taxonomy}, {Applications}, {Challenges}, and {Future} {Trends}},
	volume = {9},
	issn = {2169-3536},
	shorttitle = {An {Exhaustive} {Survey} on {P4} {Programmable} {Data} {Plane} {Switches}},
	url = {https://ieeexplore.ieee.org/document/9447791/},
	doi = {10.1109/ACCESS.2021.3086704},
	abstract = {Traditionally, the data plane has been designed with fixed functions to forward packets using a small set of protocols. This closed-design paradigm has limited the capability of the switches to proprietary implementations which are hard-coded by vendors, inducing a lengthy, costly, and inflexible process. Recently, data plane programmability has attracted significant attention from both the research community and the industry, permitting operators and programmers in general to run customized packet processing functions. This open-design paradigm is paving the way for an unprecedented wave of innovation and experimentation by reducing the time of designing, testing, and adopting new protocols; enabling a customized, top-down approach to develop network applications; providing granular visibility of packet events defined by the programmer; reducing complexity and enhancing resource utilization of the programmable switches; and drastically improving the performance of applications that are offloaded to the data plane. Despite the impressive advantages of programmable data plane switches and their importance in modern networks, the literature has been missing a comprehensive survey. To this end, this paper provides a background encompassing an overview of the evolution of networks from legacy to programmable, describing the essentials of programmable switches, and summarizing their advantages over Softwaredefined Networking (SDN) and legacy devices. The paper then presents a unique, comprehensive taxonomy of applications developed with P4 language; surveying, classifying, and analyzing more than 200 articles; discussing challenges and considerations; and presenting future perspectives and open research issues.},
	language = {en},
	urldate = {2023-01-24},
	journal = {IEEE Access},
	author = {Kfoury, Elie F. and Crichigno, Jorge and Bou-Harb, Elias},
	year = {2021},
	keywords = {Lu, P4 language, Protocols, data plane, Control systems, custom packet processing, Market research, Programmable switches, Security, Software, Software-defined Networking, taxonomy, Taxonomy, Technological innovation},
	pages = {87094--87155},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\LTMSR9U7\\9447791.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\9WUKD6M5\\Kfoury et al. - 2021 - An Exhaustive Survey on P4 Programmable Data Plane.pdf:application/pdf;Kfoury et al. - 2021 - An Exhaustive Survey on P4 Programmable Data Plane.pdf:C\:\\Users\\Yann\\Zotero\\storage\\ID7RDCZC\\Kfoury et al. - 2021 - An Exhaustive Survey on P4 Programmable Data Plane.pdf:application/pdf},
}

@article{hauser_survey_2023,
	title = {A {Survey} on {Data} {Plane} {Programming} with {P4}: {Fundamentals}, {Advances}, and {Applied} {Research}},
	volume = {212},
	issn = {10848045},
	shorttitle = {A {Survey} on {Data} {Plane} {Programming} with {P4}},
	url = {http://arxiv.org/abs/2101.10632},
	doi = {10.1016/j.jnca.2022.103561},
	abstract = {Programmable data planes allow users to deﬁne their own data plane algorithms for network devices including appropriate data plane application programming interfaces (APIs) which may be leveraged by user-deﬁned software-deﬁned networking (SDN) control. This oﬀers great ﬂexibility for network customization, be it for specialized, commercial appliances, e.g., in 5G or data center networks, or for rapid prototyping in industrial and academic research. Programming protocol-independent packet processors (P4) has emerged as the currently most widespread abstraction, programming language, and concept for data plane programming. It is developed and standardized by an open community, and it is supported by various software and hardware platforms.},
	language = {en},
	urldate = {2023-01-24},
	journal = {Journal of Network and Computer Applications},
	author = {Hauser, Frederik and Häberle, Marco and Merling, Daniel and Lindner, Steffen and Gurevich, Vladimir and Zeiger, Florian and Frank, Reinhard and Menth, Michael},
	month = mar,
	year = {2023},
	note = {arXiv:2101.10632 [cs]},
	keywords = {Computer Science - Networking and Internet Architecture},
	pages = {103561},
	file = {Hauser et al. - 2023 - A Survey on Data Plane Programming with P4 Fundam.pdf:C\:\\Users\\Yann\\Zotero\\storage\\KBUKAAAA\\Hauser et al. - 2023 - A Survey on Data Plane Programming with P4 Fundam.pdf:application/pdf},
}

@misc{the_p4org_applications_working_group_-band_2020,
	title = {In-band {Network} {Telemetry} ({INT}) {Dataplane} {Specification} v2.0},
	shorttitle = {{INT} {Dataplane} {Specification}},
	url = {https://p4.org/p4-spec/docs/telemetry_report_v1_0.pdf},
	urldate = {2023-01-23},
	author = {The P4.org Applications Working Group.},
	month = feb,
	year = {2020},
	file = {INT_v2_0.pdf:C\:\\Users\\Yann\\Zotero\\storage\\BL7A6KNY\\INT_v2_0.pdf:application/pdf},
}

@misc{noauthor_p4runtime_nodate,
	title = {{P4Runtime} {Specification}},
	url = {https://p4.org/p4-spec/p4runtime/v1.2.0/P4Runtime-Spec.html},
	urldate = {2023-01-24},
	file = {P4Runtime Specification:C\:\\Users\\Yann\\Zotero\\storage\\2AX2LWFI\\P4Runtime-Spec.html:text/html;P4Runtime Specification.pdf:C\:\\Users\\Yann\\Zotero\\storage\\7XVVKFF8\\P4Runtime Specification.pdf:application/pdf},
}

@misc{noauthor_p416_nodate,
	title = {P4{\textasciitilde}16{\textasciitilde} {Language} {Specification}},
	url = {https://p4.org/p4-spec/docs/P4-16-v1.2.2.html},
	urldate = {2023-01-24},
	file = {P4~16~ Language Specification:C\:\\Users\\Yann\\Zotero\\storage\\CCLCJUMS\\P4-16-v1.2.2.html:text/html;P4~16~ Language Specification.pdf:C\:\\Users\\Yann\\Zotero\\storage\\SQHJWGXM\\P4~16~ Language Specification.pdf:application/pdf},
}

@misc{noauthor_baidu_nodate,
	title = {Baidu {Intelligent} {Cloud} - {Intel}® {Tofino}™ {Expandable} {Architecture}},
	url = {https://www.intel.com/content/www/us/en/products/docs/programmable/baidu-tofino-xa-white-paper.html},
	abstract = {Baidu Intelligent Cloud is using Intel® Tofino™ Expandable Architecture in its cloud gateways to help meet terabit-level network traffic flows.},
	language = {en},
	urldate = {2023-01-23},
	journal = {Intel},
	keywords = {Lu},
	file = {Baidu Intelligent Cloud - Intel® Tofino™ Expandabl.pdf:C\:\\Users\\Yann\\Zotero\\storage\\NEUU4HY9\\Baidu Intelligent Cloud - Intel® Tofino™ Expandabl.pdf:application/pdf;Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\3E8Y9TFR\\baidu-tofino-xa-white-paper.html:text/html},
}

@inproceedings{luinaud_design_2021,
	address = {New York, NY, USA},
	series = {{FPGA} '21},
	title = {Design {Principles} for {Packet} {Deparsers} on {FPGAs}},
	isbn = {978-1-4503-8218-2},
	url = {https://doi.org/10.1145/3431920.3439303},
	doi = {10.1145/3431920.3439303},
	abstract = {The P4 language has drastically changed the networking field as it allows to quickly describe and implement new networking applications. Although a large variety of applications can be described with the P4 language, current programmable switch architectures impose significant constraints on P4 programs. To address this shortcoming, FPGAs have been explored as potential targets for P4 applications. P4 applications are described using three abstractions: a packet parser, match-action tables, and a packet deparser, which reassembles the output packet with the result of the match-action tables. While implementations of packet parsers and match-action tables on FPGAs have been widely covered in the literature, no general design principles have been presented for the packet deparser. Indeed, implementing a high-speed and efficient deparser on FPGAs remains an open issue because it requires a large amount of interconnections and the architecture must be tailored to a P4 program. As a result, in several works where a P4 application is implemented on FPGAs, the deparser consumes a significant proportion of chip resources. Hence, in this paper, we address this issue by presenting design principles for efficient and high-speed deparsers on FPGAs. As an artifact, we introduce a tool that generates an efficient vendor-agnostic deparser architecture from a P4 program.Our design has been validated and simulated with a cocotb-based framework.The resulting architecture is implemented on Xilinx Ultrascale+ FPGAs and supports a throughput of more than 200 Gbps while reducing resource usage by almost 10x compared to other solutions.},
	urldate = {2023-01-31},
	booktitle = {The 2021 {ACM}/{SIGDA} {International} {Symposium} on {Field}-{Programmable} {Gate} {Arrays}},
	publisher = {Association for Computing Machinery},
	author = {Luinaud, Thomas and Santiago da Silva, Jeferson and Langlois, J.M. Pierre and Savaria, Yvon},
	month = feb,
	year = {2021},
	keywords = {graph optimization, p4 language, packet deparsers, L1},
	pages = {280--286},
	annote = {Sujet: Comment optimiser l’étage d’egress sur FPGA, le talon d’Achilles des outils de synthèse existants: SDNet, P4FPGA, Compilateur Xilinx.
},
	file = {Version acceptée:C\:\\Users\\Yann\\Zotero\\storage\\ULR6WKYK\\Luinaud et al. - 2021 - Design Principles for Packet Deparsers on FPGAs.pdf:application/pdf},
}

@inproceedings{luinaud_bridging_2020,
	title = {Bridging the {Gap}: {FPGAs} as {Programmable} {Switches}},
	shorttitle = {Bridging the {Gap}},
	doi = {10.1109/HPSR48589.2020.9098978},
	abstract = {The emergence of P4, a domain specific language, coupled to PISA, a domain specific architecture, is revolutionizing the networking field. P4 allows to describe how packets are processed by a programmable data plane, spanning ASICs and CPUs, implementing PISA. Because the processing flexibility can be limited on ASICs, while the CPUs performance for networking tasks lag behind, recent works have proposed to implement PISA on FPGAs. However, little effort has been dedicated to analyze whether FPGAs are good candidates to implement PISA. In this work, we take a step back and evaluate the micro-architecture efficiency of various PISA blocks. We demonstrate, supported by a theoretical and experimental analysis, that the performance of a few PISA blocks is severely limited by the current FPGA architectures. Specifically, we show that match tables and programmable packet schedulers represent the main performance bottlenecks for FPGA-based programmable switches. Thus, we explore two avenues to alleviate these shortcomings. First, we identify network applications well tailored to current FPGAs. Second, to support a wider range of networking applications, we propose modifications to the FPGA architectures which can also be of interest out of the networking field.},
	booktitle = {2020 {IEEE} 21st {International} {Conference} on {High} {Performance} {Switching} and {Routing} ({HPSR})},
	author = {Luinaud, Thomas and Stimpfling, Thibaut and da Silva, Jeferson Santiago and Savaria, Yvon and Langlois, J.M. Pierre},
	month = may,
	year = {2020},
	note = {ISSN: 2325-5609},
	keywords = {Computer architecture, Fabrics, Field programmable gate arrays, FPGA, in-network computing, P4 language, Pipelines, PISA, Protocols, Random access memory, Scheduling algorithms},
	pages = {1--7},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\2EVVVSSC\\9098978.html:text/html;Version soumise:C\:\\Users\\Yann\\Zotero\\storage\\ECK9WX8G\\Luinaud et al. - 2020 - Bridging the Gap FPGAs as Programmable Switches.pdf:application/pdf},
}

@inproceedings{santiago_da_silva_p4-compatible_2018,
	address = {New York, NY, USA},
	series = {{FPGA} '18},
	title = {P4-{Compatible} {High}-{Level} {Synthesis} of {Low} {Latency} 100 {Gb}/s {Streaming} {Packet} {Parsers} in {FPGAs}},
	isbn = {978-1-4503-5614-5},
	url = {https://doi.org/10.1145/3174243.3174270},
	doi = {10.1145/3174243.3174270},
	abstract = {Packet parsing is a key step in SDN-aware devices. Packet parsers in SDN networks need to be both reconfigurable and fast, to support the evolving network protocols and the increasing multi-gigabit data rates. The combination of packet processing languages with FPGAs seems to be the perfect match for these requirements. In this work, we develop an open-source FPGA-based configurable architecture for arbitrary packet parsing to be used in SDN networks. We generate low latency and high-speed streaming packet parsers directly from a packet processing program. Our architecture is pipelined and entirely modeled using templated {\textbackslash}textttC++ classes. The pipeline layout is derived from a parser graph that corresponds to a P4 code after a series of graph transformation rounds. The RTL code is generated from the {\textbackslash}textttC++ description using Xilinx Vivado HLS and synthesized with Xilinx Vivado. Our architecture achieves a {\textbackslash}SI100 {\textbackslash}giga{\textbackslash}bit/{\textbackslash}second data rate in a Xilinx Virtex-7 FPGA while reducing the latency by 45\% and the LUT usage by 40\% compared to the state-of-the-art.},
	urldate = {2023-01-31},
	booktitle = {Proceedings of the 2018 {ACM}/{SIGDA} {International} {Symposium} on {Field}-{Programmable} {Gate} {Arrays}},
	publisher = {Association for Computing Machinery},
	author = {Santiago da Silva, Jeferson and Boyer, François-Raymond and Langlois, J.M. Pierre},
	month = feb,
	year = {2018},
	keywords = {Lu, p4, fpga, hls, packet parsers, programmable networks},
	pages = {147--152},
	file = {Version soumise:C\:\\Users\\Yann\\Zotero\\storage\\62329LAB\\Santiago da Silva et al. - 2018 - P4-Compatible High-Level Synthesis of Low Latency .pdf:application/pdf},
}

@misc{noauthor_composing_nodate,
	title = {Composing {Dataplane} {Programs} with μ{P4} {\textbar} {Proceedings} of the {Annual} conference of the {ACM} {Special} {Interest} {Group} on {Data} {Communication} on the applications, technologies, architectures, and protocols for computer communication},
	url = {https://dl.acm.org/doi/abs/10.1145/3387514.3405872},
	urldate = {2023-01-31},
	file = {Composing Dataplane Programs with μP4  Proceeding.pdf:C\:\\Users\\Yann\\Zotero\\storage\\K4RHTEQK\\Composing Dataplane Programs with μP4  Proceeding.pdf:application/pdf;Composing Dataplane Programs with μP4 | Proceedings of the Annual conference of the ACM Special Interest Group on Data Communication on the applications, technologies, architectures, and protocols for computer communication:C\:\\Users\\Yann\\Zotero\\storage\\U32IT56N\\3387514.html:text/html},
}

@inproceedings{fattaholmanan_p4_2021,
	address = {New York, NY, USA},
	series = {{SOSR} '21},
	title = {P4 {Weaver}: {Supporting} {Modular} and {Incremental} {Programming} in {P4}},
	isbn = {978-1-4503-9084-2},
	shorttitle = {P4 {Weaver}},
	url = {https://doi.org/10.1145/3482898.3483353},
	doi = {10.1145/3482898.3483353},
	abstract = {In this paper, we introduce P4 Weaver as an approach towards bringing modularity into the P4 language. P4 Weaver is designed to merge new data plane features into a base program in a principled and controlled way, so as to preserve the reliability of the switch. We also present an architecture for an integrated development environment that supports modular P4 programming while also safeguarding the intellectual property of the vendor code. We demonstrate the utility of P4 Weaver by adding three popular but non-trivial protocols to a P4 switch. We show that modularity is indeed beneficial and that P4 Weaver supports modularity efficiently and reliably.},
	urldate = {2023-01-31},
	booktitle = {Proceedings of the {ACM} {SIGCOMM} {Symposium} on {SDN} {Research} ({SOSR})},
	publisher = {Association for Computing Machinery},
	author = {Fattaholmanan, Ali and Baldi, Mario and Carzaniga, Antonio and Soulé, Robert},
	month = nov,
	year = {2021},
	keywords = {modular data-plane programming, source-to-source P4 compiler, L1},
	pages = {54--65},
	file = {Fattaholmanan et al. - 2021 - P4 Weaver Supporting Modular and Incremental Prog.pdf:C\:\\Users\\Yann\\Zotero\\storage\\KR24RFSG\\Fattaholmanan et al. - 2021 - P4 Weaver Supporting Modular and Incremental Prog.pdf:application/pdf},
}

@misc{chowdhury_portland_2009,
	title = {{PortLand}: {A} {Scalable} {Fault}-{Tolerant} {Layer} 2 {Data} {Center} {Network} {Fabric} {\textbar} {Mosharaf} {Chowdhury}},
	shorttitle = {{PortLand}},
	url = {https://www.mosharaf.com/blog/2009/09/22/portland-a-scalable-fault-tolerant-layer-2-data-center-network-fabric/},
	language = {en-US},
	urldate = {2023-02-01},
	author = {Chowdhury, Mosharaf},
	month = sep,
	year = {2009},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\C7H2NF4V\\portland-a-scalable-fault-tolerant-layer-2-data-center-network-fabric.html:text/html},
}

@misc{lucas_understanding_2016,
	title = {Understanding {PortLand} - {Richard} {Lucas}' {Blog}},
	url = {http://blog.richardalucas.com/2016/04/28/Understanding-PortLand/},
	urldate = {2023-02-01},
	author = {Lucas, Richard},
	year = {2016},
	keywords = {Lu},
	file = {Understanding PortLand - Richard Lucas' Blog:C\:\\Users\\Yann\\Zotero\\storage\\UATEHNCY\\Understanding-PortLand.html:text/html},
}

@misc{noauthor_vlan_2023,
	title = {{VLAN}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=VLAN&oldid=1134281103},
	abstract = {A virtual local area network (VLAN) is any broadcast domain that is partitioned and isolated in a computer network at the data link layer (OSI layer 2). In this context, virtual, refers to a physical object recreated and altered by additional logic, within the local area network. VLANs work by applying tags to network frames and handling these tags in networking systems – creating the appearance and functionality of network traffic that is physically on a single network but acts as if it is split between separate networks. In this way, VLANs can keep network applications separate despite being connected to the same physical network, and without requiring multiple sets of cabling and networking devices to be deployed.
VLANs allow network administrators to group hosts together even if the hosts are not directly connected to the same network switch. Because VLAN membership can be configured through software, this can greatly simplify network design and deployment. Without VLANs, grouping hosts according to their resource needs the labor of relocating nodes or rewiring data links. VLANs allow devices that must be kept separate to share the cabling of a physical network and yet be prevented from directly interacting with one another. This managed sharing yields gains in simplicity, security, traffic management, and economy. For example, a VLAN can be used to separate traffic within a business based on individual users or groups of users or their roles (e.g. network administrators), or based on traffic characteristics (e.g. low-priority traffic prevented from impinging on the rest of the network's functioning). Many Internet hosting services use VLANs to separate customers' private zones from one other, allowing each customer's servers to be grouped in a single network segment no matter where the individual servers are located in the data center. Some precautions are needed to prevent traffic "escaping" from a given VLAN, an exploit known as VLAN hopping.
To subdivide a network into VLANs, one configures network equipment. Simpler equipment might partition only each physical port (if even that), in which case each VLAN runs over a dedicated network cable. More sophisticated devices can mark frames through VLAN tagging, so that a single interconnect (trunk) may be used to transport data for multiple VLANs. Since VLANs share bandwidth, a VLAN trunk can use link aggregation, quality-of-service prioritization, or both to route data efficiently.},
	language = {en},
	urldate = {2023-02-02},
	journal = {Wikipedia},
	month = jan,
	year = {2023},
	note = {Page Version ID: 1134281103},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\AWUKND4W\\VLAN.html:text/html},
}

@misc{noauthor_ieee_2022,
	title = {{IEEE} 802.{1Q}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=IEEE_802.1Q&oldid=1128288082},
	abstract = {IEEE 802.1Q, often referred to as Dot1q, is the networking standard that supports virtual local area networking (VLANs) on an IEEE 802.3 Ethernet network. The standard defines a system of VLAN tagging for Ethernet frames and the accompanying procedures to be used by bridges and switches in handling such frames. The standard also contains provisions for a quality-of-service prioritization scheme commonly known as IEEE 802.1p and defines the Generic Attribute Registration Protocol.
Portions of the network which are VLAN-aware (i.e., IEEE 802.1Q conformant) can include VLAN tags.  When a frame enters the VLAN-aware portion of the network, a tag is added to represent the VLAN membership.  Each frame must be distinguishable as being within exactly one VLAN.  A frame in the VLAN-aware portion of the network that does not contain a VLAN tag is assumed to be flowing on the native VLAN.
The standard was developed by IEEE 802.1, a working group of the IEEE 802 standards committee, and continues to be actively revised. One of the notable revisions is 802.1Q-2014 which incorporated IEEE 802.1aq (Shortest Path Bridging) and much of the IEEE 802.1D standard.},
	language = {en},
	urldate = {2023-02-02},
	journal = {Wikipedia},
	month = dec,
	year = {2022},
	note = {Page Version ID: 1128288082},
	keywords = {Survolé},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\QJQXNPUS\\IEEE_802.html:text/html},
}

@misc{noauthor_ethertype_2022,
	title = {{EtherType}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://fr.wikipedia.org/w/index.php?title=EtherType&oldid=192325643},
	abstract = {EtherType est un champ d'une trame Ethernet indiquant quel est le protocole de niveau supérieur utilisé dans le champ "donnée" de cette trame.},
	language = {fr},
	urldate = {2023-02-02},
	journal = {Wikipédia},
	month = mar,
	year = {2022},
	note = {Page Version ID: 192325643},
	keywords = {Survolé},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\7E4GJ9I6\\EtherType.html:text/html},
}

@misc{noauthor_tcam_nodate,
	title = {{TCAM} demystified},
	url = {https://learningnetwork.cisco.com/s/article/tcam-demystified},
	urldate = {2023-02-03},
	file = {TCAM demystified:C\:\\Users\\Yann\\Zotero\\storage\\JIWX5LAU\\tcam-demystified.html:text/html},
}

@inproceedings{asai_palmtrie_2020,
	address = {New York, NY, USA},
	series = {{CoNEXT} '20},
	title = {Palmtrie: a ternary key matching algorithm for {IP} packet filtering rules},
	isbn = {978-1-4503-7948-9},
	shorttitle = {Palmtrie},
	url = {https://doi.org/10.1145/3386367.3431289},
	doi = {10.1145/3386367.3431289},
	abstract = {Network security has become crucial to our society and industry. A firewall is an essential function in network operations for security enhancement. Network access control lists (ACLs) have been used to describe multi-layer security rules to determine whether a packet is passed or dropped by the firewall. An entry in ACLs contains so-called don't care bits, and consequently, ACL matching is generalized as a ternary matching problem. As ternary matching typically relies on dedicated hardware, high-performance ternary matching with commodity CPUs is challenging. We propose a practical algorithm for network ACL matching trie, named Palmtrie, that allows the multi-bit stride extension to achieve better performance. We evaluate the Palmtrie using synthetic ACLs that emulate an existing campus network and Internet backbone policies. The evaluation results demonstrate that the Palmtrie outperforms the existing ACL matching algorithms on extensive ACLs. For example, the lookup performance of the optimized Palmtrie achieves 4.76 times faster than the algorithm implemented in the widely used library (DPDK) for the scanning attack traffic on an ACL with one million entries. We also prove that the Palmtrie solves the problem with the build time of data structures in the existing algorithms.},
	urldate = {2023-02-03},
	booktitle = {Proceedings of the 16th {International} {Conference} on emerging {Networking} {EXperiments} and {Technologies}},
	publisher = {Association for Computing Machinery},
	author = {Asai, Hirochika},
	month = nov,
	year = {2020},
	keywords = {access control list, firewalls, packet classification, ternary matching},
	pages = {323--335},
	file = {Asai - 2020 - Palmtrie a ternary key matching algorithm for IP .pdf:C\:\\Users\\Yann\\Zotero\\storage\\KBQNXC7G\\Asai - 2020 - Palmtrie a ternary key matching algorithm for IP .pdf:application/pdf},
}

@misc{noauthor_micronugget_nodate,
	title = {{MicroNugget}: {What} is {Multi}-{Protocol} {Label} {Switching} ({MPLS})? - {YouTube}},
	url = {https://www.youtube.com/watch?v=huKkCK8AJ7I},
	urldate = {2023-02-03},
	keywords = {Lu},
	file = {MicroNugget\: What is Multi-Protocol Label Switching (MPLS)? - YouTube:C\:\\Users\\Yann\\Zotero\\storage\\J73Y4HG8\\watch.html:text/html},
}

@inproceedings{mashreghi-moghadam_templated_2022,
	title = {A {Templated} {VHDL} {Architecture} for {Terabit}/s {P4}-programmable {FPGA}-based {Packet} {Parsing}},
	doi = {10.1109/ISCAS48785.2022.9937607},
	abstract = {This paper proposes a templated VHDL architecture for P4-programmable packet parsing on FPGAs offering high throughput while occupying a small area footprint. The architecture comprises a multi-stage header parser unit arranged in a pipelined structure. Each header analysis unit is characterized by a set of generic parameters reflecting unique features and relations of supported protocols retrieved from the P4 code that describes each stage along the pipeline. Synthesis results of the packet parser show up to 549 Gb/s throughput on a Xilinx Virtex-7 FPGA and 1 Tb/s on a Xilinx UltraScale+ for a twelve-stage pipeline. Compared with state-of-the-art solutions, our proposed architecture performs at higher throughput with acceptable resource utilization.},
	booktitle = {2022 {IEEE} {International} {Symposium} on {Circuits} and {Systems} ({ISCAS})},
	author = {Mashreghi-Moghadam, Parisa and Ould-Bachir, Tarek and Savaria, Yvon},
	month = may,
	year = {2022},
	note = {ISSN: 2158-1525},
	keywords = {FPGA, P4 language, Pipelines, Protocols, Circuits and systems, Codes, Microarchitecture, packet parser, Throughput, VHDL},
	pages = {672--676},
	file = {IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\WRUHJ4AY\\Mashreghi-Moghadam et al. - 2022 - A Templated VHDL Architecture for Terabits P4-pro.pdf:application/pdf},
}

@misc{noauthor_content-addressable_2022,
	title = {Content-addressable memory},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Content-addressable_memory&oldid=1120173075#Ternary_CAMs},
	abstract = {Content-addressable memory (CAM) is a special type of computer memory used in certain very-high-speed searching applications. It is also known as associative memory or associative storage and compares input search data against a table of stored data, and returns the address of matching data.CAM is frequently used in networking devices where it speeds up forwarding information base and routing table operations. This kind of associative memory is also used in cache memory. In associative cache memory, both address and content is stored side by side. When the address matches, the corresponding content is fetched from cache memory.},
	language = {en},
	urldate = {2023-02-03},
	journal = {Wikipedia},
	month = nov,
	year = {2022},
	note = {Page Version ID: 1120173075},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\UUCCYJF5\\Content-addressable_memory.html:text/html},
}

@misc{noauthor_static_2023,
	title = {Static random-access memory},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Static_random-access_memory&oldid=1136936708},
	abstract = {Static random-access memory (static RAM or SRAM)  is a type of random-access memory (RAM) that uses latching circuitry (flip-flop) to store each bit. SRAM is volatile memory; data is lost when power is removed.
The term static differentiates SRAM from DRAM (dynamic random-access memory) — SRAM will hold its data permanently in the presence of power, while data in DRAM decays in seconds and thus must be periodically refreshed.  SRAM is faster than DRAM but it is more expensive in terms of silicon area and cost; it is typically used for the cache and internal registers of a CPU while DRAM is used for a computer's main memory.},
	language = {en},
	urldate = {2023-02-03},
	journal = {Wikipedia},
	month = feb,
	year = {2023},
	note = {Page Version ID: 1136936708},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\9ZQTLMUH\\Static_random-access_memory.html:text/html},
}

@article{pagiamtzis_content-addressable_2006,
	title = {Content-{Addressable} {Memory} ({CAM}) {Circuits} and {Architectures}: {A} {Tutorial} and {Survey}},
	volume = {41},
	issn = {0018-9200},
	shorttitle = {Content-{Addressable} {Memory} ({CAM}) {Circuits} and {Architectures}},
	url = {http://ieeexplore.ieee.org/document/1599540/},
	doi = {10.1109/JSSC.2005.864128},
	abstract = {We survey recent developments in the design of large-capacity content-addressable memory (CAM). A CAM is a memory that implements the lookup-table function in a single clock cycle using dedicated comparison circuitry. CAMs are especially popular in network routers for packet forwarding and packet classiﬁcation, but they are also beneﬁcial in a variety of other applications that require high-speed table lookup. The main CAM-design challenge is to reduce power consumption associated with the large amount of parallel active circuitry, without sacriﬁcing speed or memory density. In this paper, we review CAM-design techniques at the circuit level and at the architectural level. At the circuit level, we review low-power matchline sensing techniques and searchline driving approaches. At the architectural level we review three methods for reducing power consumption.},
	language = {en},
	number = {3},
	urldate = {2023-02-03},
	journal = {IEEE Journal of Solid-State Circuits},
	author = {Pagiamtzis, K. and Sheikholeslami, A.},
	month = mar,
	year = {2006},
	keywords = {Lu, Application software, Bank selection, CADCAM, Circuits, Clocks, Computer aided manufacturing, content-addressable memory (CAM), Energy consumption, Image coding, IP networks, matchline pipelining, matchline sensing, NAND cell, NOR cell, review, searchline power, Table lookup, Tutorial},
	pages = {712--727},
	file = {Pagiamtzis et Sheikholeslami - 2006 - Content-Addressable Memory (CAM) Circuits and Arch.pdf:C\:\\Users\\Yann\\Zotero\\storage\\TAS5523Y\\Pagiamtzis et Sheikholeslami - 2006 - Content-Addressable Memory (CAM) Circuits and Arch.pdf:application/pdf},
}

@article{chisvin_content-addressable_1989,
	title = {Content-addressable and associative memory: alternatives to the ubiquitous {RAM}},
	volume = {22},
	issn = {0018-9162},
	shorttitle = {Content-addressable and associative memory},
	url = {http://ieeexplore.ieee.org/document/30732/},
	doi = {10.1109/2.30732},
	number = {7},
	urldate = {2023-02-03},
	journal = {Computer},
	author = {Chisvin, L. and Duckworth, R.J.},
	month = jul,
	year = {1989},
	pages = {51--64},
}

@article{pei_putting_1992,
	title = {Putting routing tables in silicon},
	volume = {6},
	issn = {0890-8044},
	url = {http://ieeexplore.ieee.org/document/120723/},
	doi = {10.1109/65.120723},
	number = {1},
	urldate = {2023-02-03},
	journal = {IEEE Network},
	author = {Pei, T.-B. and Zukowski, C.},
	month = jan,
	year = {1992},
	pages = {42--50},
	file = {Pei et Zukowski - 1992 - Putting routing tables in silicon.pdf:C\:\\Users\\Yann\\Zotero\\storage\\N3LEVBUE\\Pei et Zukowski - 1992 - Putting routing tables in silicon.pdf:application/pdf},
}

@inproceedings{stas_associative_1993,
	address = {Portland, OR, USA},
	title = {Associative processing with {CAMs}},
	isbn = {978-0-7803-9972-3},
	url = {http://ieeexplore.ieee.org/document/505050/},
	doi = {10.1109/NORTHC.1993.505050},
	urldate = {2023-02-03},
	booktitle = {Proceedings of {NORTHCON}'93 {Electrical} and {Electronics} {Convention}},
	publisher = {IEEE},
	author = {Stas, S.},
	year = {1993},
	pages = {161--167},
}

@book{oleary_essential_2004,
	address = {London ; Thoundand Oaks},
	title = {The essential guide to doing research},
	isbn = {978-0-7619-4198-9 978-0-7619-4199-6},
	language = {en},
	publisher = {SAGE},
	author = {O'Leary, Zina},
	year = {2004},
	note = {OCLC: ocm55736969},
	keywords = {Methodology, Research},
	file = {O'Leary - 2004 - The essential guide to doing research.pdf:C\:\\Users\\Yann\\Zotero\\storage\\8XKCSRYE\\O'Leary - 2004 - The essential guide to doing research.pdf:application/pdf},
}

@article{cao_p4_2020,
	title = {P4 to {FPGA}-{A} {Fast} {Approach} for {Generating} {Efficient} {Network} {Processors}},
	volume = {8},
	issn = {2169-3536},
	doi = {10.1109/ACCESS.2020.2970683},
	abstract = {This paper presents a framework for converting P4 programs to VHDL and then implementing them on Field-Programmable Gate Array (FPGA) platforms. In this framework, a match-action-based hardware architecture is introduced with clearly designed components, which correspond to the described functionalities in the P4 programs. A pre-built template library is used for the compilation that includes optimized VHDL templates corresponding to specific clearly designed components. From the output of a standard frontend P4 compiler, the proposed compiler extracts parameters and relationships within the functions being employed, maps them to corresponding templates by calling, configuring, optimizing and instantiating them, and finally generates the appropriate FPGA code. A pre-built evaluation library is also proposed that helps the compiler to optimize the implementation during the mapping phase. A prototype of this framework is also implemented and evaluated; in this process, it is found that the generated processors use few resources and have high throughput and low latency. Compared with a state-of-the-art solution, the packet processing time is halved. In addition, the generated processors are able to operate at a line rate of nearly 100 Gigabits per second for a basic layer-3 forwarding application.},
	journal = {IEEE Access},
	author = {Cao, Zhuang and Su, Huayou and Yang, Qianming and Shen, Junzhong and Wen, Mei and Zhang, Chunyuan},
	year = {2020},
	note = {Conference Name: IEEE Access},
	keywords = {Computer architecture, Field programmable gate arrays, FPGA, VHDL, Clocks, Hardware, network processor, P4, Program processors, template},
	pages = {23440--23456},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\BES7JRJ4\\8976091.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\2UUBR4AN\\Cao et al. - 2020 - P4 to FPGA-A Fast Approach for Generating Efficien.pdf:application/pdf},
}

@inproceedings{yang_elastic_2018,
	address = {New York},
	title = {Elastic {Sketch}: {Adaptive} and {Fast} {Network}-wide {Measurements}},
	isbn = {978-1-4503-5567-4},
	shorttitle = {Elastic {Sketch}},
	url = {https://dl.acm.org/doi/10.1145/3230543.3230544},
	doi = {10.1145/3230543.3230544},
	abstract = {When network is undergoing problems such as congestion, scan attack, DDoS attack, etc., measurements are much more important than usual. In this case, traffic characteristics including available bandwidth, packet rate, and flow size distribution vary drastically, significantly degrading the performance of measurements. To address this issue, we propose the Elastic sketch. It is adaptive to currently traffic characteristics. Besides, it is generic to measurement tasks and platforms. We implement the Elastic sketch on six platforms: P4, FPGA, GPU, CPU, multi-core CPU, and OVS, to process six typical measurement tasks. Experimental results and theoretical analysis show that the Elastic sketch can adapt well to traffic characteristics. Compared to the state-of-the-art, the Elastic sketch achieves 44.6 similar to 45.2 times faster speed and 2.0 similar to 273.7 smaller error rate.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Proceedings of the 2018 {Conference} of the {Acm} {Special} {Interest} {Group} on {Data} {Communication} (sigcomm '18)},
	publisher = {Assoc Computing Machinery},
	author = {Yang, Tong and Jiang, Jie and Liu, Peng and Huang, Qun and Gong, Junzhi and Zhou, Yang and Miao, Rui and Li, Xiaoming and Uhlig, Steve},
	year = {2018},
	note = {WOS:000482127900039},
	keywords = {Compression, Elastic, Generic, Network measurements, Sketches},
	pages = {561--575},
}

@inproceedings{miao_silkroad_2017,
	address = {New York},
	title = {{SilkRoad}: {Making} {Stateful} {Layer}-4 {Load} {Balancing} {Fast} and {Cheap} {Using} {Switching} {ASICs}},
	isbn = {978-1-4503-4653-5},
	shorttitle = {{SilkRoad}},
	url = {https://dl.acm.org/doi/10.1145/3098822.3098824},
	doi = {10.1145/3098822.3098824},
	abstract = {In this paper, we show that up to hundreds of software load balancer (SLB) servers can be replaced by a single modern switching ASIC, potentially reducing the cost of load balancing by over two orders of magnitude. Today, large data centers typically employ hundreds or thousands of servers to load-balance incoming traffic over application servers. These software load balancers (SLBs) map packets destined to a service (with a virtual IP address, or VIP), to a pool of servers tasked with providing the service (with multiple direct IP addresses, or DIPs). An SLB is stateful, it must always map a connection to the same server, even if the pool of servers changes and/or if the load is spread differently across the pool. This property is called per-connection consistency or PCC. The challenge is that the load balancer must keep track of millions of connections simultaneously. Until recently, it was not possible to implement a load balancer with PCC in a merchant switching ASIC, because high-performance switching ASICs typically can not maintain per-connection states with PCC. Newer switching ASICs provide resources and primitives to enable PCC at a large scale. In this paper, we explore how to use switching ASICs to build much faster load balancers than have been built before. Our system, called SilkRoad, is defined in a 400 line P4 program and when compiled to a state-of-the-art switching ASIC, we show it can load-balance ten million connections simultaneously at line rate.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Sigcomm '17: {Proceedings} of the 2017 {Conference} of the {Acm} {Special} {Interest} {Group} on {Data} {Communication}},
	publisher = {Assoc Computing Machinery},
	author = {Miao, Rui and Zeng, Hongyi and Kim, Changhoon and Lee, Jeongkeun and Yu, Minlan},
	year = {2017},
	note = {WOS:000414280000002},
	keywords = {Programmable switches, Load balancing},
	pages = {15--28},
}

@inproceedings{handley_re-architecting_2017,
	address = {New York},
	title = {Re-architecting datacenter networks and stacks for low latency and high performance},
	isbn = {978-1-4503-4653-5},
	url = {https://dl.acm.org/doi/10.1145/3098822.3098825},
	doi = {10.1145/3098822.3098825},
	abstract = {Modern datacenter networks provide very high capacity via redundant Clos topologies and low switch latency, but transport protocols rarely deliver matching performance. We present NDP, a novel data-center transport architecture that achieves near-optimal completion times for short transfers and high flow throughput in a wide range of scenarios, including incast. NDP switch buffers are very shallow and when they fill the switches trim packets to headers and priority forward the headers. This gives receivers a full view of instantaneous demand from all senders, and is the basis for our novel, high-performance, multipath-aware transport protocol that can deal gracefully with massive incast events and prioritize traffic from different senders on RTT timescales. We implemented NDP in Linux hosts with DPDK, in a software switch, in a NetFPGA-based hardware switch, and in P4. We evaluate NDP's performance in our implementations and in large-scale simulations, simultaneously demonstrating support for very low-latency and high throughput.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Sigcomm '17: {Proceedings} of the 2017 {Conference} of the {Acm} {Special} {Interest} {Group} on {Data} {Communication}},
	publisher = {Assoc Computing Machinery},
	author = {Handley, Mark and Raiciu, Costin and Agache, Alexandru and Voinescu, Andrei and Moore, Andrew W. and Antichi, Gianni and Wojcik, Marcin},
	year = {2017},
	note = {WOS:000414280000003},
	keywords = {Datacenters, Network Stacks, Transport Protocols},
	pages = {29--42},
	file = {Texte intégral:C\:\\Users\\Yann\\Zotero\\storage\\DRX7CB2K\\Handley et al. - 2017 - Re-architecting datacenter networks and stacks for.pdf:application/pdf},
}

@inproceedings{ibanez_p4_2019,
	address = {New York},
	title = {The {P4} -{\textgreater} {NetFPGA} {Workflow} for {Line}-{Rate} {Packet} {Processing}},
	isbn = {978-1-4503-6137-8},
	url = {https://dl.acm.org/doi/10.1145/3289602.3293924},
	doi = {10.1145/3289602.3293924},
	abstract = {P4 has emerged as the de facto standard language for describing how network packets should be processed, and is becoming widely used by network owners, systems developers, researchers and in the classroom. The goal of the work presented here is to make it easier for engineers, researchers and students to learn how to program using P4, and to build prototypes running on real hardware. Our target is the NetFPGA SUME platform, a 4 x 10 Gb/s PCIe card designed for use in universities for teaching and research. Until now, NetFPGA users have needed to learn an HDL such as Verilog or VHDL, making it off limits to many software developers and students. Therefore, we developed the P4 -{\textgreater} NetFPGA workflow, allowing developers to describe how packets are to be processed in the high-level P4 language, then compile their P4 programs to run at line rate on the NetFPGA SUME board. The P4 -{\textgreater} NetFPGA workflow is built upon the Xilinx P4-SDNet compiler and the NetFPGA SUME open source code base. In this paper, we provide an overview of the P4 programming language and describe the P4 -{\textgreater} NetFPGA workflow. We also describe how the workflow is being used by the P4 community to build research prototypes, and to teach how network systems are built by providing students with hands-on experience working with real hardware.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Proceedings of the 2019 {Acm}/{Sigda} {International} {Symposium} on {Field}-{Programmable} {Gate} {Arrays} (fpga'19)},
	publisher = {Assoc Computing Machinery},
	author = {Ibanez, Stephen and Brebner, Gordon and McKeown, Nick and Zilberman, Noa},
	year = {2019},
	note = {WOS:000522383700001},
	keywords = {L1},
	pages = {1--9},
	file = {Ibanez et al. - 2019 - The P4 - NetFPGA Workflow for Line-Rate Packet Pr.pdf:C\:\\Users\\Yann\\Zotero\\storage\\FMI8P2BN\\Ibanez et al. - 2019 - The P4 - NetFPGA Workflow for Line-Rate Packet Pr.pdf:application/pdf},
}

@book{ridley_literature_2012,
	title = {The {Literature} {Review}: {A} {Step}-by-{Step} {Guide} for {Students}},
	isbn = {978-1-4462-6804-9},
	shorttitle = {The {Literature} {Review}},
	abstract = {This second edition of Diana Ridley′s bestselling book provides a step-by-step guide to conducting a literature search and literature review, using cases and examples throughout to demonstrate best practice. Ridley outlines practical strategies for conducting a systematic search of the available literature, reading and note taking and writing up your literature review as part of an undergraduate research project, Masters dissertation or PhD thesis. New to this edition are:  Examples drawn from a wide range of disciplines  A new chapter on conducting systematic reviews  Increased guidance on evaluating the quality of online sources and online literature  Enhanced guidance in dealing with copyright and permissions issues.   This book also comes with a companion website containing a wide range of examples of successful literature reviews from various academic disciplines.  SAGE Study Skills are essential study guides for students of all levels. From how to write great essays and succeeding at university, to writing your undergraduate dissertation and doing postgraduate research, SAGE Study Skills help you get the best from your time at university. Visit the SAGE Study Skills hub for tips, quizzes and videos on study success!},
	language = {en},
	publisher = {SAGE},
	author = {Ridley, Diana},
	month = jul,
	year = {2012},
	keywords = {Reference / Research, Study Aids / General},
}

@incollection{hauck_introduction_2008,
	address = {Burlington},
	series = {Systems on {Silicon}},
	title = {Introduction},
	url = {https://www.sciencedirect.com/science/article/pii/B9780123705228500030},
	language = {en},
	urldate = {2023-02-10},
	booktitle = {Reconfigurable {Computing}},
	publisher = {Morgan Kaufmann},
	editor = {Hauck, Scott and Dehon, André},
	month = jan,
	year = {2008},
	doi = {10.1016/B978-012370522-8.50003-0},
	keywords = {Lu},
	pages = {xxv--xxix},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\64Z5HXD2\\Hauck et Dehon - 2008 - Introduction.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\FJ3DZM4C\\reconfigurable-computing.html:text/html},
}

@incollection{chang_device_2008,
	title = {Device {Architecture}},
	isbn = {978-0-12-370522-8},
	url = {https://linkinghub.elsevier.com/retrieve/pii/B9780123705228500054},
	language = {en},
	urldate = {2023-02-10},
	booktitle = {Reconfigurable {Computing}: {The} {Theory} and {Practice} of {FPGA}-{Based} {Computation}},
	publisher = {Elsevier},
	author = {Chang, Mark L.},
	year = {2008},
	doi = {10.1016/B978-012370522-8.50005-4},
	keywords = {Lu},
	pages = {3--27},
	file = {Chang - 2008 - Device Architecture.pdf:C\:\\Users\\Yann\\Zotero\\storage\\E8955ABF\\Chang - 2008 - Device Architecture.pdf:application/pdf},
}

@misc{noauthor_multiprotocol_2023,
	title = {Multiprotocol {Label} {Switching}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Multiprotocol_Label_Switching&oldid=1137499050},
	abstract = {Multiprotocol Label Switching (MPLS) is a routing technique in telecommunications networks that directs data from one node to the next based on labels rather than network addresses. Whereas network addresses identify endpoints the labels identify established paths between endpoints. MPLS can encapsulate packets of various network protocols, hence the multiprotocol component of the name. MPLS supports a range of access technologies, including T1/E1, ATM, Frame Relay, and DSL.},
	language = {en},
	urldate = {2023-02-14},
	journal = {Wikipedia},
	month = feb,
	year = {2023},
	note = {Page Version ID: 1137499050},
	keywords = {Survolé},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\ZAY7IBBQ\\Multiprotocol_Label_Switching.html:text/html},
}

@book{noauthor_oracle_2004,
	title = {Oracle {VM} {VirtualBox} {User} {Manual}},
	url = {https://www.virtualbox.org/manual/},
	urldate = {2023-01-20},
	year = {2004},
	keywords = {Lu partiellement},
	file = {VirtualBox_user_manual.pdf:C\:\\Users\\Yann\\Zotero\\storage\\FSLBQKBC\\VirtualBox_user_manual.pdf:application/pdf},
}

@misc{noauthor_von_nodate,
	title = {Von {Neumann} architecture - {Wikipedia}},
	url = {https://en.wikipedia.org/wiki/Von_Neumann_architecture#Von_Neumann_bottleneck},
	urldate = {2023-02-17},
	keywords = {Lu partiellement},
	annote = {Section: Von Neumann bottleneck
},
	file = {Von Neumann architecture - Wikipedia:C\:\\Users\\Yann\\Zotero\\storage\\DS2DF9NF\\Von_Neumann_architecture.html:text/html},
}

@misc{noauthor_reconfigurable_2022,
	title = {Reconfigurable computing},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Reconfigurable_computing&oldid=1107624488},
	abstract = {Reconfigurable computing is a computer architecture combining some of the flexibility of software with the high performance of hardware by processing with very flexible high speed computing fabrics like field-programmable gate arrays (FPGAs). The principal difference when compared to using ordinary microprocessors is the ability to make substantial changes to the datapath itself in addition to the control flow. On the other hand, the main difference from custom hardware, i.e. application-specific integrated circuits (ASICs) is the possibility to adapt the hardware during runtime by "loading" a new circuit on the reconfigurable fabric.},
	language = {en},
	urldate = {2023-02-17},
	journal = {Wikipedia},
	month = aug,
	year = {2022},
	note = {Page Version ID: 1107624488},
	keywords = {Lu},
	annote = {Résumé: le moyen principal d’ajouter de la reconfigurabilité est d’avoir une architecture partiellement reconfigurable. Xilinx et Intel ont tous les deux certains modèles conçus pour être reconfigurables. Deux types de FPGAs partiellement reconfigurables:
Statique: on a pas besoin de réécrire tout le bitstream pour la reconfiguration, mais tout le FPGA doit être reset pendant le processus
Dynamique: plus intéressant, toute la partie non-reconfigurée du FPGA continue à fonctionner pendant qu’on reconfigure le reste.
La reconfigurabilité est permise par le design hiérarchique et modulaire: typiquement, on reconfigure une entité séparément du reste. Par exemple, un périphérique ou un coprocesseur connecté au CPU.
Avis: pas super, l’écriture part un peu dans tout les sens, passe trop de temps sur les différences entre FPGAs à granularité fine ou grossière. Pas de ligne directrice claire.
},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\9NEGQ7VW\\Reconfigurable_computing.html:text/html},
}

@misc{noauthor_translation_2023,
	title = {Translation lookaside buffer},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Translation_lookaside_buffer&oldid=1135682679},
	abstract = {A translation lookaside buffer (TLB) is a memory cache that stores the recent translations of virtual memory to physical memory. It is used to reduce the time taken to access a user memory location. It can be called an address-translation cache.  It is a part of the chip's memory-management unit (MMU). A TLB may reside between the CPU and the CPU cache, between CPU cache and the main memory or between the different levels of the multi-level cache. The majority of desktop, laptop, and server processors include one or more TLBs in the memory-management hardware, and it is nearly always present in any processor that utilizes paged or segmented virtual memory.
The TLB is sometimes implemented as content-addressable memory (CAM). The CAM search key is the virtual address, and the search result is a physical address. If the requested address is present in the TLB, the CAM search yields a match quickly and the retrieved physical address can be used to access memory. This is called a TLB hit. If the requested address is not in the TLB, it is a miss, and the translation proceeds by looking up the page table in a process called a page walk. The page walk is time-consuming when compared to the processor speed, as it involves reading the contents of multiple memory locations and using them to compute the physical address. After the physical address is determined by the page walk, the virtual address to physical address mapping is entered into the TLB.  The PowerPC 604, for example, has a two-way set-associative TLB for data loads and stores. Some processors have different instruction and data address TLBs.},
	language = {en},
	urldate = {2023-02-17},
	journal = {Wikipedia},
	month = jan,
	year = {2023},
	note = {Page Version ID: 1135682679},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\HWVGF6AF\\Translation_lookaside_buffer.html:text/html},
}

@misc{noauthor_page_2022,
	title = {Page table},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Page_table&oldid=1083393269},
	abstract = {A page table is the data structure used by a virtual memory system in a computer operating system to store the mapping between virtual addresses and physical addresses.  Virtual addresses are used by the program executed by the accessing process, while physical addresses are used by the hardware, or more specifically, by the random-access memory (RAM) subsystem. The page table is a key component of virtual address translation that is necessary to access data in memory.},
	language = {en},
	urldate = {2023-02-17},
	journal = {Wikipedia},
	month = apr,
	year = {2022},
	note = {Page Version ID: 1083393269},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\4TFV8QCF\\Page_table.html:text/html},
}

@inproceedings{yong_feng_situ_2021,
	address = {New York, NY, USA},
	series = {{HotNets} '21},
	title = {In situ {Programmable} {Switching} using {rP4}: {Towards} {Runtime} {Data} {Plane} {Programmability}},
	isbn = {978-1-4503-9087-3},
	shorttitle = {In situ {Programmable} {Switching} using {rP4}},
	url = {https://doi.org/10.1145/3484266.3487367},
	doi = {10.1145/3484266.3487367},
	abstract = {The existing chip architecture and programming language are incapable of supporting in-service updates by loading or offloading on-demand protocols and functions at runtime. We examine the fundamental reasons for the inflexibility and design a new In-situ Programmable Switch Architecture (IPSA) as a fix. We further design rP4, a P4 extension, for programming IPSA-based devices. To manifest the in-situ programming feasibility, we develop an rP4 compiler and demonstrate several use cases on both a software switch, ipbm, and an FPGA-based prototype. Our preliminary experiments and analysis show that, compared to PISA, IPSA provides higher flexibility in enabling runtime functional update with limited performance and gate-count penalty. The in-situ programming capability enabled by IPSA and rP4 opens a promising design space for programmable networks.},
	urldate = {2023-02-20},
	booktitle = {Proceedings of the {Twentieth} {ACM} {Workshop} on {Hot} {Topics} in {Networks}},
	publisher = {Association for Computing Machinery},
	author = {{Yong Feng} and Song, Haoyu and Li, Jiahao and Chen, Zhikang and Xu, Wenquan and Liu, Bin},
	month = nov,
	year = {2021},
	keywords = {Lu, L1},
	pages = {69--76},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\3M4998FH\\Feng et al. - 2021 - In-situ Programmable Switching using rP4 Towards .pdf:application/pdf},
}

@inproceedings{benacek_p4--vhdl_2016,
	title = {P4-to-{VHDL}: {Automatic} {Generation} of 100 {Gbps} {Packet} {Parsers}},
	shorttitle = {P4-to-{VHDL}},
	doi = {10.1109/FCCM.2016.46},
	abstract = {Software Defined Networking and OpenFlow offer an elegant way to decouple network control plane from data plane. This decoupling has led to great innovation in the control plane, yet the data plane changes come at much slower pace, mainly due to the hard-wired implementation of network switches. The P4 language aims to overcome this obstacle by providing a description of a customized packet processing functionality for configurable switches. That enables a new generation of possibly heterogeneous networking hardware that can be runtime tailored for the needs of particular applications from various domains. In this paper we contribute to the idea of P4 by presenting design, analysis and experimental results of our packet parser generator. The generator converts a parse graph description of P4 to a synthetizable VHDL code suitable for FPGA implementation. Our results show that the generated circuit is able to parse 100 Gbps traffic with fairly complex protocol structure at line rate on a Xilinx Virtex-7 FPGA. The approach can be used not only in switches, but also in other appliances, such as application accelerators and smart NICs. We compare the generated output to a hand-written parser to show that the price for configurability is only a slightly larger and slower circuit.},
	booktitle = {2016 {IEEE} 24th {Annual} {International} {Symposium} on {Field}-{Programmable} {Custom} {Computing} {Machines} ({FCCM})},
	author = {Benácek, Pavel and Pu, Viktor and Kubátová, Hana},
	month = may,
	year = {2016},
	keywords = {Computer architecture, Field programmable gate arrays, Pipelines, Protocols, Program processors, Data mining, Generators},
	pages = {148--155},
	annote = {Avis: génération VHDL, puis synthèse sous Vivado.
Le papier ne dit pas si les ‘tests’ mentionnés ont été faits en simulation ou avec des vrais paquets.
},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\NGASQLCB\\7544769.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\4SHYU5S9\\Benácek et al. - 2016 - P4-to-VHDL Automatic Generation of 100 Gbps Packe.pdf:application/pdf},
}

@misc{noauthor_intel_nodate,
	title = {Intel {Learning}},
	url = {https://learning.intel.com/developer/learn/course/external/view/elearning/378/partial-reconfiguration-for-intel-fpga-devices-pr-host-ip-implementations},
	urldate = {2023-02-21},
}

@article{kastovsky_building_nodate,
	title = {Building a {PoC} of {Segment} {Routing} at {100G} {Using} {FPGA} {Smart} {NIC} and {P4} {Language}},
	language = {en},
	author = {Kaštovský, Petr},
	file = {Kaštovský - Building a PoC of Segment Routing at 100G Using FP.pdf:C\:\\Users\\Yann\\Zotero\\storage\\QH6P9HH7\\Kaštovský - Building a PoC of Segment Routing at 100G Using FP.pdf:application/pdf},
}

@inproceedings{yazdinejad_p4_2018,
	title = {P4 to {SDNet}: {Automatic} {Generation} of an {Efficient} {Protocol}-{Independent} {Packet} {Parser} on {Reconfigurable} {Hardware}},
	shorttitle = {P4 to {SDNet}},
	doi = {10.1109/ICCKE.2018.8566590},
	abstract = {Nowadays network managers look for ways to change the design and management of networks that can make decisions on the control plane. Future switches should be able to support the new features and flexibility required for parsing and processing packets. One of the critical components of switches is the packet parser that processes the headers of the packets to be able to decide on the incoming packets. Here the data plane, and particularly packet parser in OpenFlow switches, which should have the flexibility and programmability to support the new requirements and OpenFlow multiple versions, are focused. Designed here is an architecture that unlike the static network equipments, it has the flexibility and programmability in the data plane network, especially the SDN network, and supports the parsing and processing of specific packets. To describe this architecture, a high-level P4 language is used to implement it on a reconfigurable hardware (i.e., FPGA). After automatic generating the protocol-independent Packet parser architecture on the Virtex-7, it is compiled to firmware by Xilinx SDNet, and ultimately an FPGA Platform is implemented. It has fewer consumption resources and it is more efficient in terms of throughput and processing speed in comparison with other architectures.},
	booktitle = {2018 8th {International} {Conference} on {Computer} and {Knowledge} {Engineering} ({ICCKE})},
	author = {Yazdinejad, Abbas and Bohlooli, Ali and Jamshidi, Kamal},
	month = oct,
	year = {2018},
	note = {ISSN: 2375-1304},
	keywords = {Computer architecture, Field programmable gate arrays, Pipelines, Protocols, Hardware, P4, Program processors, Data Plane, Delays, OpenFlow Switch, Packet Parser, Reconfigurable Hardware, SDNet},
	pages = {159--164},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\3T8BHV47\\8566590.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\MDX65UFM\\Yazdinejad et al. - 2018 - P4 to SDNet Automatic Generation of an Efficient .pdf:application/pdf},
}

@article{amd_xilinx_inc_vitis_2022,
	title = {Vitis {Networking} {P4} {User} {Guide}},
	language = {en},
	urldate = {2023-02-21},
	author = {{AMD Xilinx Inc.}},
	year = {2022},
	file = {2022 - Vitis Networking P4 User Guide.pdf:C\:\\Users\\Yann\\Zotero\\storage\\UF8EUF9Y\\2022 - Vitis Networking P4 User Guide.pdf:application/pdf},
}

@misc{noauthor_intelligent_nodate,
	title = {Intelligent fabric processors - {Tofino} - {Switch} to intelligence},
	url = {https://www.intel.com/content/www/ca/en/products/network-io/programmable-ethernet-switch/tofino-3-product-brochure.html},
	abstract = {Upgrade from fixed-function Ethernet switches to Intel Tofino P4 programmable intelligent fabric processors.},
	language = {en},
	urldate = {2023-02-22},
	journal = {Intel},
	file = {Intelligent fabric processors - Tofino - Switch to.pdf:C\:\\Users\\Yann\\Zotero\\storage\\LQXMBPHI\\Intelligent fabric processors - Tofino - Switch to.pdf:application/pdf;Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\X7M6V2L5\\tofino-3-product-brochure.html:text/html},
}

@inproceedings{xing_vision_2021,
	address = {New York, NY, USA},
	series = {{HotNets} '21},
	title = {A {Vision} for {Runtime} {Programmable} {Networks}},
	isbn = {978-1-4503-9087-3},
	url = {https://doi.org/10.1145/3484266.3487377},
	doi = {10.1145/3484266.3487377},
	abstract = {Our community has made significant progress in developing programmable network infrastructure, starting from the control plane and expanding to the data plane. As a latest trend, network devices are becoming runtime programmable while serving live traffic. This allows for reprogramming of individual device programs at fine-grained timescales to add or remove network functions. Many applications and services, however, need control over a combination of devices, including end host stacks, NICs, and switches, to accomplish their goals. We lay out our vision for runtime programmable networks, building upon device-level features to provide live, network-wide, runtime reprogramming. A whole-stack approach is needed with new programming models, compiler support, and network management abstractions. We outline a research agenda as a call to arms to the community.},
	urldate = {2023-02-24},
	booktitle = {Proceedings of the {Twentieth} {ACM} {Workshop} on {Hot} {Topics} in {Networks}},
	publisher = {Association for Computing Machinery},
	author = {Xing, Jiarong and Qiu, Yiming and Hsu, Kuo-Feng and Liu, Hongyi and Kadosh, Matty and Lo, Alan and Akella, Aditya and Anderson, Thomas and Krishnamurthy, Arvind and Ng, T. S. Eugene and Chen, Ang},
	month = nov,
	year = {2021},
	keywords = {L1, Programmable networks},
	pages = {91--98},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\BPZ4K4DV\\Xing et al. - 2021 - A Vision for Runtime Programmable Networks.pdf:application/pdf},
}

@misc{amd_xilinx_inc_introduction_2022,
	title = {Introduction • {Getting} {Started} with {Alveo} {Data} {Center} {Accelerator} {Cards} {User} {Guide} ({UG1301}) • {Reader} • {Documentation} {Portal}},
	url = {https://docs.xilinx.com/r/en-US/ug1301-getting-started-guide-alveo-accelerator-cards/Introduction},
	urldate = {2023-02-24},
	author = {{AMD Xilinx Inc.}},
	month = dec,
	year = {2022},
	keywords = {Lu},
}

@article{noauthor_getting_2022,
	title = {Getting {Started} with {Alveo} {Data} {Center} {Accelerator} {Cards}},
	language = {en},
	year = {2022},
	keywords = {Lu},
	file = {2022 - Getting Started with Alveo Data Center Accelerator.pdf:C\:\\Users\\Yann\\Zotero\\storage\\WAKNJ4KT\\2022 - Getting Started with Alveo Data Center Accelerator.pdf:application/pdf;Introduction • Getting Started with Alveo Data Center Accelerator Cards User Guide (UG1301) • Reader • Documentation Portal:C\:\\Users\\Yann\\Zotero\\storage\\CLADNTFX\\Introduction.html:text/html},
}

@inproceedings{xing_runtime_2022,
	title = {Runtime {Programmable} {Switches}},
	isbn = {978-1-939133-27-4},
	url = {https://www.usenix.org/conference/nsdi22/presentation/xing},
	language = {en},
	urldate = {2023-02-27},
	author = {Xing, Jiarong and Hsu, Kuo-Feng and Kadosh, Matty and Lo, Alan and Piasetzky, Yonatan and Krishnamurthy, Arvind and Chen, Ang},
	year = {2022},
	pages = {651--665},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\A6ZIH8AC\\Xing et al. - 2022 - Runtime Programmable Switches.pdf:application/pdf},
}

@misc{noauthor_content_nodate,
	title = {Content {Addressable} {Memory} ({CAM})},
	url = {https://www.xilinx.com/products/intellectual-property/ef-di-cam.html},
	language = {en},
	urldate = {2023-03-01},
	journal = {Xilinx},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\Q5F9FIPV\\ef-di-cam.html:text/html},
}

@phdthesis{santiago_da_silva_fully_2020,
	address = {Ann Arbor, United States},
	type = {Ph.{D}.},
	title = {Fully {Programming} the {Data} {Plane}: {A} {Hardware}/{Software} {Approach}},
	copyright = {Database copyright ProQuest LLC; ProQuest does not claim copyright in the individual underlying works.},
	shorttitle = {Fully {Programming} the {Data} {Plane}},
	url = {https://www.proquest.com/pqdtglobal/docview/2626888963/abstract/DA1E3B00DD1C4DCDPQ/1},
	abstract = {Software-Defined Networking (SDN) has emerged in recent years as a new network paradigm to de-ossify communication networks. Indeed, by offering a clear separation of network concerns between the management, control, and data planes, SDN allows each of these planes to evolve independently, breaking the rigidity of traditional networks. However, while well spread in the control and management planes, this de-ossification has only recently reached the data plane with the advent of packet processing languages, e.g. P4, and novel programmable switch architectures, e.g. Protocol Independent Switch Architecture (PISA). In this work, we focus on leveraging the PISA architecture by mainly exploiting the FPGA capabilities for efficient packet processing. In this way, we address this issue at different abstraction levels: i) microarchitectural; ii) programming; and, iii) architectural.
Autre résumé:
Les réseaux définis par logiciel — en anglais Software-Defined Networking (SDN) — sont apparus ces dernières années comme un nouveau paradigme de réseau. SDN introduit une séparation entre les plans de gestion, de contrôle et de données, permettant à ceux-ci d’évoluer de manière indépendante, rompant ainsi avec la rigidité des réseaux traditionnels. En particulier, dans le plan de données, les avancées récentes ont porté sur la définition des langages de traitement de paquets, tel que P4, et sur la définition d’architectures de commutateurs programmables, par exemple la Protocol Independent Switch Architecture (PISA). Dans cette thèse, nous nous intéressons a l’architecture PISA et évaluons comment exploiter les FPGA comme plateforme de traitement efficace de paquets. Cette problématique est étudiée a trois niveaux d’abstraction : microarchitectural, programmation et architectural.},
	language = {Anglais},
	urldate = {2023-03-02},
	author = {Santiago da Silva, Jeferson},
	year = {2020},
	note = {ISBN: 9798759978060},
	keywords = {Field programmable gate arrays, Software, Algorithms, C plus plus, Computer centers, Computer science, Design, Graph representations, Integrated circuits, Operating systems, Servers},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\KI643GNK\\Santiago da Silva - 2020 - Fully Programming the Data Plane A HardwareSoftw.pdf:application/pdf},
}

@phdthesis{luinaud_algorithmes_2017,
	address = {Ann Arbor, United States},
	type = {M.{A}.{Sc}.},
	title = {Algorithmes et architectures pour l'implémentation de la détection d'expressions régulières},
	copyright = {Database copyright ProQuest LLC; ProQuest does not claim copyright in the individual underlying works.},
	url = {https://www.proquest.com/pqdtglobal/docview/2025446962/abstract/CC59E42171714DEEPQ/1},
	abstract = {La prochaine génération de réseau mobile, la 5G, devrait supporter des latences 10 fois plus faibles avec des débits et un nombre d’appareils connectés 100 fois plus importants qu’aujourd’hui. Dans le même temps, les opérateurs et les gestionnaires de réseaux veulent des systèmes plus modulaires qui puissent s’adapter rapidement aux nouveaux protocoles, mais qui ne consomment pas plus d’énergie que les solutions actuelles. Les opérateurs et administrateurs sont donc de plus en plus intéressés par des plateformes reconfigurables telles que des FPGA. Cependant, ces plateformes nécessitent encore des experts pour être utilisées et ont des temps de développement qui peuvent être longs ce qui les rend difficiles à intégrer. De plus, les infrastructures informatiques sont des éléments de plus en plus critiques pour le fonctionnement de l’économie. La sécurité des réseaux est donc devenue un point important pour protéger ces infrastructures. Actuellement la protection des réseaux est effectuée en utilisant des Systèmes de Détection d’Intrusions — Intrusion Detection System (IDS) qui effectuent l’inspection en profondeur de paquets — Deep Packet Inspection (DPI). Pour permettre la protection, les IDS comparent le contenu des paquets transitant sur le réseau à des règles prédéterminées. Ces règles sont représentées soit par des chaînes de caractères ou bien des expressions régulières. Dans ce mémoire, nous proposons trois contributions en rapport à l’utilisation de FPGA pour effectuer de la recherche de texte et d’expressions régulières dans les réseaux. Ces trois réalisations sont implémentées sur des FPGA et respectent les contraintes de latence liées aux réseaux.

Autre résumé:
The next generation of mobile networks, called 5G, is expected to achieve significantly better performance than present networks : latency 10x smaller, throughput 100x higher with 100x more connected devices over the so-called 4G. Moreover, service providers and network administrators will need more configurable systems able to rapidly support new protocols. Furthermore, the power consumption of the resulting network infrastructure remains a critical consideration. A possible solution to meet all those requirements involves the use of FPGAs. However, the development complexity causes integration difficulties. In addition, computers and data-centers are more and more critical systems. Consequently, security is an important issue. This motivates introducing Intrusion Detection Systems (IDS), which perform Deep Packet Inspection (DPI). IDSs compare the network flow against a set of rules that are expressed with strings and regular expressions. This thesis proposes three contributions in regard to FPGAs utilization for text and regular expression search. Those contributions respect the latency constraint of networks and are implemented into FPGAs.},
	language = {Français},
	urldate = {2023-03-02},
	author = {Luinaud, Thomas},
	year = {2017},
	note = {ISBN: 9798209562009},
	keywords = {(UMI)AAI10806598, Applied sciences},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\VQD4HS5D\\Luinaud - 2017 - Algorithmes et architectures pour l'implémentation.pdf:application/pdf},
}

@phdthesis{stimpfling_memoires_2020,
	address = {Ann Arbor, United States},
	type = {Ph.{D}.},
	title = {Mémoires {Associatives} {Algorithmiques} pour l'{Opération} de {Recherche} du {Plus} {Long} {Préfixe} sur {FPGA}},
	copyright = {Database copyright ProQuest LLC; ProQuest does not claim copyright in the individual underlying works.},
	url = {https://www.proquest.com/pqdtglobal/docview/2626025255/abstract/B6CB9FD033BC4015PQ/1},
	abstract = {Les réseaux prédiﬀusés programmables — en anglais Field Programmable Gate Arrays (FPGAs)— sont omniprésents dans les centres de données, pour accélérer des tâches d’indexations et d’apprentissage machine, mais aussi plus récemment, pour accélérer des opérations réseaux. Dans cette thèse, nous nous intéressons à l’opération de recherche du plus long préﬁxe en anglais Longest Preﬁx Match (LPM) — sur FPGA. Cette opération est utilisée soit pour router des paquets, soit comme un bloc de base dans un plan de données programmable. Bien que l’opération LPM soit primordiale dans un réseau, celle-ci souﬀre d’ineﬃcacité sur FPGA. Dans cette thèse, nous démontrons que la performance de l’opération LPM sur FPGA peut être substantiellement améliorée en utilisant une approche algorithmique, où l’opération LPM est implémentée à l’aide d’une structure de données. Par ailleurs, les résultats présentés permettent de réﬂéchir à une question plus large : est-ce que l’architecture des FPGA devrait être spécialisée pour les applications réseaux ? Premièrement, pour l’application de routage IPv6 dans le réseau Internet, nous présentons SHIP. Cette solution exploite les caractéristiques des préﬁxes pour construire une structure de données compacte, pouvant être implémentée de manière eﬃcace sur FPGA. SHIP utilise l’approche ńdiviser pour régnerż pour séparer les préﬁxes en groupes de faible cardinalité et ayant des caractéristiques similaires. Les préﬁxes contenus dans chaque groupe sont en-suite encodés dans une structure de données hybride, où l’encodage des préﬁxes est adapté suivant leurs caractéristiques. Sur FPGA, SHIP augmente l’eﬃcacité de l’opération LPM comparativement à l’état de l’art, tout en supportant un débit supérieur à 100 Gb/s. Deuxièment, nous présentons comment implémenter eﬃcacement l’opération LPM pour un plan de données programmable sur FPGA. Dans ce cas, contrairement au routage de pa-quets, aucune connaissance à priori des préﬁxes ne peut être utilisée. Par conséquent, nous présentons un cadre de travail comprenant une structure de données eﬃcace, indépendam-ment des caractéristiques des préﬁxes contenus, et des méthodes permettant d’implémenter eﬃcacement la structure de données sur FPGA. Un arbre B, étendu pour l’opération LPM, est utilisé en raison de sa faible complexité algorithmique. Nous présentons une méthode pour allouer à la compilation le minimum de ressources requis par l’abre B pour encoder un ensemble de préﬁxes, indépendamment de leurs caractéristiques. Plusieurs méthodes sont ensuite présentées pour augmenter l’eﬃcacité mémoire après implémentation de la structure de données sur FPGA. Évaluée sur plusieurs scénarios, cette solution est capable de traiter plus de 100 Gb/s, tout en améliorant la performance par rapport à l’état de l’art.
Autre résumé:
FPGAs are becoming ubiquitous in data centers. First introduced to accelerate indexing services and machine learning tasks, FPGAs are now also used to accelerate networking operations, including the LPM operation. This operation is used for packet routing and as a building block in programmable data planes. However, for the two uses cases considered, the LPM operation is ineﬃciently implemented in FPGAs. In this thesis, we demonstrate that the performance of LPM operation can be signiﬁcantly improved using an algorithmic approach, where the LPM operation is implemented using a data structure. In addition, using the results presented in this thesis, we can answer a broader question: Should the FPGA architecture be specialized for networking? First, we present the SHIP data structure that is tailored to routing IPv6 packets in the Internet network. SHIP exploits the preﬁx characteristics to build a compact data structure that can be eﬃciently mapped to FPGAs. First, SHIP uses a "divide and conquer" approach to bin preﬁxes in groups with a small cardinality and sharing similar characteristics. Second, a hybrid-trie-tree data structure is used to encode the preﬁxes held in each group. The hybrid data structure adapts the preﬁx encoding method to their characteristics. Then, we demonstrated that SHIP can be eﬃciently implemented in FPGAs. Implemented on FPGAs, the proposed solution improves the memory eﬃciency over the state of the art solutions, while supporting a packet throughput greater than 100 Gbps.While the preﬁxes and their characteristics are known when routing packets in the Internet network, this is not true for programmable data planes. Hence, the second solution, designed for programmable data planes, does not exploit any prior knowledge of the preﬁx stored. We present a framework comprising an eﬃcient data structure to encode the preﬁxes and methods to map the data structure eﬃciently to FPGAs. First, the framework leverages a B-tree, extended to support the LPM operation, for its low algorithmic complexity. Second, we present a method to allocate at compile time the minimum amount of resources that can be used by the B-tree. Third, our framework selects the B-tree parameters to increase the post-implementation memory eﬃciency and generates the corresponding hardware architecture. Implemented on FPGAs, this solution supports packet throughput greater than 100 Gbps, while improving the performance over the state of the art.},
	language = {Français},
	urldate = {2023-03-02},
	author = {Stimpfling, Thibaut},
	year = {2020},
	note = {ISBN: 9798759977360},
	keywords = {Algorithms, Computer engineering, Efficiency, Electrical engineering, Indexing services, Internet},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\GTNBVXHE\\Stimpfling - 2020 - Mémoires Associatives Algorithmiques pour l'Opérat.pdf:application/pdf},
}

@article{avedisov_awareness_2021,
	title = {Awareness {Assessment} of {Connected} {Vehicles} in {Highway} {Driving}: {A} {Perceived} {Safety} {Approach}},
	volume = {16},
	issn = {1556-6080},
	shorttitle = {Awareness {Assessment} of {Connected} {Vehicles} in {Highway} {Driving}},
	doi = {10.1109/MVT.2021.3076982},
	abstract = {This article showcases a perceived safety analysis framework to assess the awareness of connected vehicles (CVs) of surrounding safety-critical vehicles. We study two classes of messages that a CV can transmit: 1) messages containing information about the transmitter only [e.g., standardized basic safety messages (BSMs) and cooperative awareness messages (CAMs)], and 2) messages that aggregate information about the transmitter and surrounding objects detected by their onboard sensors [e.g., collective perception messages (CPMs)]. We show how the proposed framework allows one to identify safety-critical vehicles and the effect of the type of transmitted messages on the awareness of these critical vehicles. To evaluate the performance, we use experimental data with mixed traffic of unconnected vehicles and CVs at different penetration ratios. Results show that CPMs are significantly more effective at providing awareness of safety-critical vehicles at low-to-mid-connectivity penetrations. At high-connectivity penetrations, messages with only information about the transmitter are sufficient to provide full awareness without burdening the wireless channel.},
	number = {3},
	journal = {IEEE Vehicular Technology Magazine},
	author = {Avedisov, Sergei and Sakr, Ahmed Hamdi and Higuchi, Takamasa and Yamamuro, Akihiko and Altintas, Onur},
	month = sep,
	year = {2021},
	note = {Conference Name: IEEE Vehicular Technology Magazine},
	keywords = {Cams, Connected vehicles, Measurement, Safety, Sensors, Transmitters, Wireless communication, Wireless sensor networks},
	pages = {129--136},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\KAGDDY3R\\9440961.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\LWJDUXMB\\Avedisov et al. - 2021 - Awareness Assessment of Connected Vehicles in High.pdf:application/pdf},
}

@article{silva_information-driven_2019,
	title = {Information-{Driven} {Software}-{Defined} {Vehicular} {Networks}: {Adapting} {Flexible} {Architecture} to {Various} {Scenarios}},
	volume = {14},
	issn = {1556-6080},
	shorttitle = {Information-{Driven} {Software}-{Defined} {Vehicular} {Networks}},
	doi = {10.1109/MVT.2018.2867356},
	abstract = {Vehicular ad hoc network (VANET) applications have emerged as new opportunities for the automobile industry to provide advanced services for connecting vehicles and their users. Most of these services, such as safety, information, and entertainment systems, require a variety of digital content to be delivered to and from vehicles. In this article, we propose a novel, information-driven, software-defined architecture designed to make content available to vehicular networks. In contrast to the existing solutions, our proposed architecture is flexible and covers important aspects of content delivery in VANETs. To assess the benefits of our proposal, we have implemented a case study to compare it with two baseline solutions.},
	number = {1},
	journal = {IEEE Vehicular Technology Magazine},
	author = {Silva, Fabricio A. and Boukerche, Azzedine and Silva, Thais R.M.B. and Cerqueira, Eduardo and Ruiz, Linnyer B. and Loureiro, Antonio A.F.},
	month = mar,
	year = {2019},
	note = {Conference Name: IEEE Vehicular Technology Magazine},
	keywords = {Protocols, Vehicular and wireless technologies, Information technology, Monitoring, Network topology, Semantics, Software defined networking, Vehicular ad hoc networks},
	pages = {98--107},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\56HKIZHL\\8606420.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\TBPKG2QW\\Silva et al. - 2019 - Information-Driven Software-Defined Vehicular Netw.pdf:application/pdf},
}

@article{valle_automated_2021,
	title = {Automated {Decision} {System} to {Exploit} {Network} {Diversity} for {Connected} {Vehicles}},
	volume = {70},
	issn = {1939-9359},
	doi = {10.1109/TVT.2020.3046413},
	abstract = {In this work, we introduce a methodology that takes advantage of the inherent network diversity present in vehicular communications to improve the performance of safety applications. This methodology is based on a framework that simultaneously exploits the strengths of each individual network by using a set of decision rules. The implementation begins with a manual approach in which a typical, hierarchical decision tree characterizes the decision process of a single application when sending data to other users in the network. Analytical and simulation results validate the decision system approach when diversity is exploited as demonstrated by a boost in application performance, achieving an average latency under 100 ms and a 40\% increase in throughput due to the increased packet delivery ratio. We then apply an ensemble learning technique, Random Forests (RF), to automatically reproduce the performance of the manually built tree system. Simulations under realistic traffic scenarios show the RF approach can replicate manually-built tree performance with up to 98\% precision. A comparison with another state-of-the-art hybrid method also shows the RF scheme improves performance under a different application scenario without additional manual adjustments. With our methodology, we can add different application requirements and network characteristics to obtain a fully automated and adaptable decision system to optimize vehicular safety applications.},
	number = {1},
	journal = {IEEE Transactions on Vehicular Technology},
	author = {Valle, Felipe and Céspedes, Sandra and Hafid, Abdelhakim Senhaji},
	month = jan,
	year = {2021},
	note = {Conference Name: IEEE Transactions on Vehicular Technology},
	keywords = {Computer architecture, Throughput, Connected vehicles, Safety, decision system, decision tree learning, heterogeneous networks, Long Term Evolution, Quality of service, random forest, Standards, Vegetation},
	pages = {858--871},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\VUXSNEMW\\9305961.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\WRFUDHSW\\Valle et al. - 2021 - Automated Decision System to Exploit Network Diver.pdf:application/pdf},
}

@article{noauthor_vitis_2022,
	title = {Vitis {Networking} {P4} {Getting} {Started} {Guide}},
	language = {en},
	year = {2022},
	file = {2022 - Vitis Networking P4 Getting Started Guide.pdf:C\:\\Users\\Yann\\Zotero\\storage\\Y4WSSUYJ\\2022 - Vitis Networking P4 Getting Started Guide.pdf:application/pdf},
}

@misc{noauthor_equal-cost_2023,
	title = {Equal-cost multi-path routing},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Equal-cost_multi-path_routing&oldid=1135151625},
	abstract = {Equal-cost multi-path routing (ECMP) is a routing strategy where packet forwarding to a single destination can occur over multiple best paths with equal routing priority. Multi-path routing can be used in conjunction with most routing protocols because it is a per-hop local decision made independently at each router. It can substantially increase bandwidth by load-balancing traffic over multiple paths; however, there may be significant problems in deploying it in practice.},
	language = {en},
	urldate = {2023-03-08},
	journal = {Wikipedia},
	month = jan,
	year = {2023},
	note = {Page Version ID: 1135151625},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\NCLVKE5X\\Equal-cost_multi-path_routing.html:text/html},
}

@article{lai_security_2020,
	title = {Security and {Privacy} {Challenges} in {5G}-{Enabled} {Vehicular} {Networks}},
	volume = {34},
	issn = {1558-156X},
	doi = {10.1109/MNET.001.1900220},
	abstract = {Recently, many academic institutions and standardization organizations have conducted research on vehicular communications based on LTE or 5G. As the most important standardization organization of cellular systems, the 3rd Generation Partnership Project (3GPP) has been developing the standard supporting vehicle-to-everything (V2X) services based on LTE, and has already prepared the roadmap toward 5G-based V2X services. With the emergence of new technologies and applications, such as connected autonomous vehicles, 5G-enabled vehicular networks face a variety of security and privacy challenges, which have not been fully investigated. In this article, we first present the infrastructure of 5G-enabled vehicular networks. Then the essential security and privacy aspects of V2X in LTE specified by 3GPP are introduced. After that, as a case study, we investigate the security and privacy issues of a 5G-enabled autonomous platoon, and propose several candidate solutions, including secure group setup with privacy preservation, distributed group key management, and cooperative message authentication. Finally, we discuss the security and privacy challenges in 5G-enabled vehicular networks.},
	number = {2},
	journal = {IEEE Network},
	author = {Lai, Chengzhe and Lu, Rongxing and Zheng, Dong and Shen, Xuemin},
	month = mar,
	year = {2020},
	note = {Conference Name: IEEE Network},
	keywords = {Security, Autonomous vehicles, Long Term Evolution, 3GPP, 5G mobile communication, Privacy, Vehicle-to-everything},
	pages = {37--45},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\U58TAP48\\9055735.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\JXLJE3W9\\Lai et al. - 2020 - Security and Privacy Challenges in 5G-Enabled Vehi.pdf:application/pdf},
}

@misc{noauthor_virtual_2021,
	title = {Virtual routing and forwarding},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://fr.wikipedia.org/w/index.php?title=Virtual_routing_and_forwarding&oldid=181688604},
	abstract = {Virtual routing and forwarding (VRF) est une technologie dans le domaine des réseaux informatiques qui permet à plusieurs instances d'une table de routage de coexister dans le même routeur en même temps. 
Étant donné que les instances de routage sont indépendantes, les adresses IP identiques ou qui se chevauchent peuvent être utilisées sans conflit les unes avec les autres. La fonctionnalité réseau est améliorée car des réseaux IP peuvent être segmentés sans nécessiter plusieurs routeurs.
Une VRF peut être implémenté dans un périphérique réseau par une paire de tables de routage (RIB – Routing Information Base) et de transmission (FIB – Forwarding Information Base) distinctes, une par instance de routage. En variante, un périphérique réseau peut avoir la capacité de configurer différents routeurs virtuels, chacun ayant ses propre RIB et FIB qui ne seront accessibles à aucune autre instance de routeur virtuel sur le même périphérique.},
	language = {fr},
	urldate = {2023-03-10},
	journal = {Wikipédia},
	month = apr,
	year = {2021},
	note = {Page Version ID: 181688604},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\SMDYNMWY\\Virtual_routing_and_forwarding.html:text/html},
}

@inproceedings{mo_overview_2022,
	title = {An {Overview} of {SRv6} {Standardization} and {Application} towards {5G}-{Advanced} and {6G}},
	doi = {10.1109/CCET55412.2022.9906338},
	abstract = {Segment Routing over IPv6 (SRv6) is a source routing technique based on IPv6 data plane, which has been widely concerned. Benefit from its simplicity, scalability and programmability, SRv6 has been proposed to be introduced into mobile core network in 3GPP and IETF. SRv6 related standards and applications include alternative user plane protocol of core network, service function chaining, computing power network and smarter user plane. This paper will make a theoretical analysis of SRv6 and then overview the situation of SRv6 standardization and application. Finally, the development of SRv6 in standardization is prospected. With development of 5G-Advanced and 6G, SRv6 can contribute to leverage Software Defined Network (SDN) and Network Function Virtualization (NFV) in mobile network and facilitate fixed mobile convergence.},
	booktitle = {2022 {IEEE} 5th {International} {Conference} on {Computer} and {Communication} {Engineering} {Technology} ({CCET})},
	author = {Mo, Zhiwei and Long, Biao},
	month = aug,
	year = {2022},
	keywords = {Protocols, 3GPP, 6G mobile communication, IETF, Network function virtualization, Routing, Scalability, Service function chaining, SRv6, standards, user plane, Virtual private networks, Pas ouf},
	pages = {266--270},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\JCHMPX9V\\stamp.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\8EK9I8GM\\Mo et Long - 2022 - An Overview of SRv6 Standardization and Applicatio.pdf:application/pdf},
}

@article{vipin_fpga_2018,
	title = {{FPGA} {Dynamic} and {Partial} {Reconfiguration}: {A} {Survey} of {Architectures}, {Methods}, and {Applications}},
	volume = {51},
	issn = {0360-0300},
	shorttitle = {{FPGA} {Dynamic} and {Partial} {Reconfiguration}},
	url = {https://doi.org/10.1145/3193827},
	doi = {10.1145/3193827},
	abstract = {Dynamic and partial reconfiguration are key differentiating capabilities of field programmable gate arrays (FPGAs). While they have been studied extensively in academic literature, they find limited use in deployed systems. We review FPGA reconfiguration, looking at architectures built for the purpose, and the properties of modern commercial architectures. We then investigate design flows and identify the key challenges in making reconfigurable FPGA systems easier to design. Finally, we look at applications where reconfiguration has found use, as well as proposing new areas where this capability places FPGAs in a unique position for adoption.},
	number = {4},
	urldate = {2023-03-10},
	journal = {ACM Computing Surveys},
	author = {Vipin, Kizheppatt and Fahmy, Suhaib A.},
	month = jul,
	year = {2018},
	keywords = {Field programmable gate arrays, dynamic reconfiguration, partial reconfiguration},
	pages = {72:1--72:39},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\FJFKRB6V\\Vipin et Fahmy - 2018 - FPGA Dynamic and Partial Reconfiguration A Survey.pdf:application/pdf},
}

@article{elbediwy_dr-pifo_nodate,
	title = {{DR}-{PIFO}: {A} {Dynamic} {Ranking} {Packet} {Scheduler} {Using} a {Push}-{In}-{First}-{Out} {Queue}},
	abstract = {Software-defined Networking (SDN) introduced the decoupling of control and data forwarding planes. Despite advances in the programmability of SDNs, there remains a strong need for a fully programmable packet scheduler in the data plane. In this context, the ability to adapt to various traffic patterns and the expressiveness of schedulers are of paramount importance. This paper introduces the Dynamic Ranking Push-In-First-Out (DR-PIFO), as an algorithmic model that can be used to develop programmable packet schedulers based on PIFO queues. The DR-PIFO is a highly expressive model, capable of expressing a wide range of work-conserving, non-work-conserving, and hierarchical scheduling algorithms. Additionally, its dynamic ranking capabilities allow for real-time updates to the packet’s priority within the scheduler. The proposed solution also performs error detection in the departure order of packets, which is essential to avoid starvation in strict priority scheduling. These features are crucial when implementing popular scheduling algorithms such as the pFabric. The DR-PIFO is evaluated through its algorithmic properties and by implementing two distinct case studies. Its performance is further evaluated by incorporating it as an external module, written in a high-level language, and integrating it with software switches implemented using the P4 language. The results illustrate the superior expressiveness of DR-PIFO over state-of-the-art models such as PIFO and PIEO and confirm that it is an algorithm-agnostic model. Thus, DRPIFO represents a promising solution for implementing more fully programmable packet schedulers in SDNs, with the potential to improve performance and adaptability.},
	language = {en},
	author = {Elbediwy, Mostafa and Pontikakis, Bill and Ghaffari, Alireza and David, Jean-Pierre and Savaria, Yvon},
	file = {Elbediwy et al. - DR-PIFO A Dynamic Ranking Packet Scheduler Using .pdf:C\:\\Users\\Yann\\Zotero\\storage\\PYRXS39F\\Elbediwy et al. - DR-PIFO A Dynamic Ranking Packet Scheduler Using .pdf:application/pdf},
}

@article{rahmati_modular_nodate,
	title = {Modular {Code} {Parser} for the {P4} {Language}},
	abstract = {We present an extension over the open-source P4C compiler, for modular header parsers for the P4 language. Modularity is essential to obtain code reusability, composability, and incremental programming. The modular parser includes matching and resolving names of the identifiers of two parser graphs, comparing them, and finally merging them. A significant feature of this modular parser is the backward compatibility of pre-existing P4 codes. It permits merging parsing codes automatically and allows to offer vendor-customer compatibility without having to learn new syntax or annotations.},
	language = {en},
	author = {Rahmati, Mohsen and Boyer, François-Raymond and Pontikakis, Bill and David, Jean-Pierre and Savaria, Yvon},
	keywords = {Lu},
	annote = {L’écriture est broche-à-foin… la prochaine fois je leur offrirai de repasser sur la syntaxe.
},
	file = {Rahmati et al. - Modular Code Parser for the P4 Language.pdf:C\:\\Users\\Yann\\Zotero\\storage\\TGWI5BMW\\Rahmati et al. - Modular Code Parser for the P4 Language.pdf:application/pdf},
}

@book{bhattacherjee_cisp_2022,
	title = {{cISP}: {A} {Speed}-of-{Light} {Internet} {Service} {Provider}},
	isbn = {978-1-939133-27-4},
	shorttitle = {{cISP}},
	abstract = {Low latency is a requirement for a variety of interactive network applications. The Internet, however, is not optimized for latency. We thus explore the design of wide-area networks that move data at nearly the speed of light in vacuum. Our cISP design augments the Internet's fiber with free-space microwave wireless connectivity over paths very close to great-circle paths. cISP addresses the fundamental challenge of simultaneously providing ultra-low latency while accounting for numerous practical factors ranging from transmission tower availability to packet queuing. We show that instantiations of cISP across the United States and Europe would achieve mean latencies within 5\% of that achievable using great-circle paths at the speed of light, over medium and long distances. Further, using experiments conducted on a nearly-speed-of-light algorithmic trading network, together with an analysis of trading data at its end points, we show that microwave networks are reliably faster than fiber networks even in inclement weather. Finally, we estimate that the economic value of such networks would substantially exceed their expense},
	language = {en},
	publisher = {USENIX Association},
	author = {Bhattacherjee, Debopam and Aqeel, Waqar and Jyothi, Sangeetha Abdu and Bozkurt, Ilker Nadi and Sentosa, William and Tirmazi, Muhammad and Aguirre, Anthony and Chandrasekaran, Balakrishnan and Godfrey, P. Brighten and Laughlin, Gregory},
	month = aug,
	year = {2022},
	note = {OCLC: 9711077437},
	keywords = {Lu},
	file = {Bhattacherjee et al. - 2022 - cISP A Speed-of-Light Internet Service Provider.pdf:C\:\\Users\\Yann\\Zotero\\storage\\7L4ZJRW2\\Bhattacherjee et al. - 2022 - cISP A Speed-of-Light Internet Service Provider.pdf:application/pdf},
}

@article{elbediwy_testbench_2023,
	title = {A {Testbench} for {Testing} {Programmable} {Traffic} {Managers} in a {Software} {Environment}},
	journal = {P4 Workshop submission},
	author = {Elbediwy, Mostafa},
	month = mar,
	year = {2023},
	keywords = {Lu},
	file = {p4workshop2023-paper13_Mostafa.pdf:C\:\\Users\\Yann\\Zotero\\storage\\I6ZJC3BL\\p4workshop2023-paper13_Mostafa.pdf:application/pdf},
}

@article{feng_enabling_2022,
	title = {Enabling {In}-situ {Programmability} in {Network} {Data} {Plane}: {From} {Architecture} to {Language}},
	url = {https://atc.usenix.org/system/files/nsdi22-paper-feng.pdf},
	abstract = {In-situ programmability refers to the capability for network devices to update data plane functions and protocol processing logic at runtime without interrupting the services, driven by dynamic and interactive network operations towards autonomous networks. The existing programmable switch architecture (e.g., PISA) and programming language (e.g., P4) were designed for monolithic and static implementation, which requires a complete programming and deployment cycle for functional update, incurring long delay and service interruption. Addressing the fundamental reasons for such inﬂexibility, we design a new In-situ Programmable Switch Architecture (IPSA) and the corresponding design ﬂow using rP4, a P4 language extension, as a ﬁx. The compiler contains algorithms to support efﬁcient resource mapping for both base design and incremental updates. To manifest the in-situ programming feasibility, we demonstrate several practical use cases on both a software switch, ipbm, and an FPGA-based prototype. Our experiments and analysis show that IPSA incurs moderate hardware cost which can be justiﬁed by its beneﬁts and compensated by newer chip technologies. The in-situ programmability enabled by IPSA and rP4 advances the state of the art of programmable networks and opens a promising new design space.},
	language = {en},
	journal = {19th USENIX Symposium on Networked Systems Design and Implementation},
	author = {Feng, Yong and Chen, Zhikang and Song, Haoyu and Xu, Wenquan and Li, Jiahao and Zhang, Zijian and Yun, Tong and Wan, Ying and Liu, Bin},
	month = apr,
	year = {2022},
	keywords = {L2},
	file = {Feng et al. - Enabling In-situ Programmability in Network Data P.pdf:C\:\\Users\\Yann\\Zotero\\storage\\M8LWDSPF\\Feng et al. - Enabling In-situ Programmability in Network Data P.pdf:application/pdf},
}

@misc{noauthor_guide_nodate,
	title = {Guide},
	url = {https://github.com/NetFPGA/netfpga/wiki/Guide},
	abstract = {NetFPGA 1G infrastructure and gateware. Contribute to NetFPGA/netfpga development by creating an account on GitHub.},
	language = {en},
	urldate = {2023-03-17},
	journal = {GitHub},
	keywords = {Lu},
	annote = {Le guide de la première NetFPGA; qui utilisait des paires torsadées. Pas utile de lire le détail du Setup.
},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\H8RZBZS5\\Guide.html:text/html},
}

@misc{noauthor_home_nodate,
	title = {Home},
	url = {https://github.com/NetFPGA/NetFPGA-public/wiki/Home},
	abstract = {NetFPGA public repository. Contribute to NetFPGA/NetFPGA-public development by creating an account on GitHub.},
	language = {en},
	urldate = {2023-03-17},
	journal = {GitHub},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\W5Q5GQHF\\wiki.html:text/html},
}

@misc{noauthor_netfpganetfpga-plus_nodate,
	title = {{NetFPGA}/{NetFPGA}-{PLUS}},
	url = {https://github.com/NetFPGA/NetFPGA-PLUS},
	urldate = {2023-03-17},
	file = {NetFPGA/NetFPGA-PLUS:C\:\\Users\\Yann\\Zotero\\storage\\ETFIVESR\\NetFPGA-PLUS.html:text/html},
}

@misc{noauthor_home_nodate-1,
	title = {Home · {NetFPGA}/{NetFPGA}-{SUME}-public {Wiki}},
	url = {https://github.com/NetFPGA/NetFPGA-SUME-public/wiki},
	urldate = {2023-03-17},
	file = {Home · NetFPGA/NetFPGA-SUME-public Wiki:C\:\\Users\\Yann\\Zotero\\storage\\FH74G6P3\\wiki.html:text/html},
}

@misc{noauthor_qsfp28_nodate,
	title = {{QSFP28}},
	url = {https://www.broadcom.com/products/fiber-optic-modules-components/networking/optical-transceivers/qsfp28},
	abstract = {The QFP28 (Quad Small Form Pluggable) transceiver form factor was established to enable multi-lane (quad) optical transceivers, such as 100GbE and 128GFC, with a variety of optical connectors (such as},
	language = {en},
	urldate = {2023-03-17},
}

@misc{noauthor_getting_nodate,
	title = {Getting {Started} {Guide}},
	url = {https://github.com/NetFPGA/NetFPGA-SUME-public/wiki/Getting-Started-Guide},
	abstract = {NetFPGA-SUME public repository. Contribute to NetFPGA/NetFPGA-SUME-public development by creating an account on GitHub.},
	language = {en},
	urldate = {2023-03-17},
	journal = {GitHub},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\6M9S4X7V\\Getting-Started-Guide.html:text/html},
}

@misc{noauthor_reference_nodate,
	title = {Reference {Operating} {System} {Setup} {Guide}},
	url = {https://github.com/NetFPGA/NetFPGA-SUME-public/wiki/Reference-Operating-System-Setup-Guide},
	abstract = {NetFPGA-SUME public repository. Contribute to NetFPGA/NetFPGA-SUME-public development by creating an account on GitHub.},
	language = {en},
	urldate = {2023-03-17},
	journal = {GitHub},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\J97MEXXN\\Reference-Operating-System-Setup-Guide.html:text/html},
}

@misc{noauthor_acceptance_nodate,
	title = {Acceptance {Test} {Project} · {NetFPGA}/{NetFPGA}-{SUME}-public {Wiki}},
	url = {https://github.com/NetFPGA/NetFPGA-SUME-public/wiki/Acceptance-Test-Project},
	urldate = {2023-03-17},
	file = {Acceptance Test Project · NetFPGA/NetFPGA-SUME-public Wiki:C\:\\Users\\Yann\\Zotero\\storage\\CN6GL2ZA\\Acceptance-Test-Project.html:text/html},
}

@misc{noauthor_conference_nodate,
	title = {Conference {Ranks}},
	url = {http://www.conferenceranks.com/#data},
	urldate = {2023-03-20},
	file = {Conference Ranks:C\:\\Users\\Yann\\Zotero\\storage\\BJIJAAQN\\www.conferenceranks.com.html:text/html},
}

@misc{jijinfanhua_rp4-language_2021,
	title = {{rP4}-language},
	url = {https://github.com/jijinfanhua/rP4-language},
	urldate = {2023-03-20},
	author = {jijinfanhua},
	month = may,
	year = {2021},
	note = {original-date: 2021-05-07T08:31:44Z},
}

@article{jiang_survey_2015,
	title = {A survey on {Information}-centric {Networking}: {Rationales}, designs and debates},
	volume = {12},
	issn = {1673-5447},
	shorttitle = {A survey on {Information}-centric {Networking}},
	doi = {10.1109/CC.2015.7188520},
	abstract = {The basic function of the Internet is to delivery data (what) to serve the needs of all applications. IP names the attachment points (where) to facilitate ubiquitous interconnectivity as the current way to deliver data. The fundamental mismatch between data delivery and naming attachment points leads to a lot of challenges, e.g., mapping from data name to IP address, handling dynamics of underlying topology, scaling up the data distribution, and securing communication, etc. Information-centric networking (ICN) is proposed to shift the focus of communication paradigm from where to what, by making the named data the first-class citizen in the network, The basic consensus of ICN is to name the data independent from its container (space dimension) and session (time dimension), which breaks the limitation of point-to-point IP semantic. It scales up data distribution by utilizing available resources, and facilitates communication to fit diverse connectivity and heterogeneous networks. However, there are only a few consensuses on the detailed design of ICN, and quite a few different ICN architectures are proposed. This paper reveals the rationales of ICN from the perspective of the Internet evolution, surveys different design choices, and discusses on two debatable topics in ICN, i.e., self-certifying versus hierarchical names, and edge versus pervasive caching. We hope this survey helps clarify some mis-understandings on ICN and achieve more consensuses.},
	number = {7},
	journal = {China Communications},
	author = {Jiang, Xiaoke and Bi, Jun and Nan, Guoshun and Li, Zhaogeng},
	month = jul,
	year = {2015},
	note = {Conference Name: China Communications},
	keywords = {Protocols, IP networks, Internet, Routing, content-centric networking, future internet architecture, Heterogeneous networks, information-centric networking, named-data networking, Proposals, publish-subscribe, Topology},
	pages = {1--12},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\ZSP3SFRM\\7188520.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\7NMSIXJZ\\Jiang et al. - 2015 - A survey on Information-centric Networking Ration.pdf:application/pdf},
}

@article{liatifis_advancing_2023,
	title = {Advancing {SDN} from {OpenFlow} to {P4}: {A} {Survey}},
	volume = {55},
	issn = {0360-0300},
	shorttitle = {Advancing {SDN} from {OpenFlow} to {P4}},
	url = {https://dl.acm.org/doi/10.1145/3556973},
	doi = {10.1145/3556973},
	abstract = {Software-defined Networking (SDN) marked the beginning of a new era in the field of networking by decoupling the control and forwarding processes through the OpenFlow protocol. The Next Generation SDN is defined by Open Interfaces and full programmability of the data plane. P4 is a domain-specific language that fulfills these requirements and has known wide adoption over recent years from Academia and Industry. This work is an extensive survey of the P4 language covering domains of application, a detailed overview of the language, and future directions.},
	number = {9},
	urldate = {2023-03-27},
	journal = {ACM Computing Surveys},
	author = {Liatifis, Athanasios and Sarigiannidis, Panagiotis and Argyriou, Vasileios and Lagkas, Thomas},
	month = jan,
	year = {2023},
	keywords = {programmable networks, P4, Next Generation SDN, SDN},
	pages = {186:1--186:37},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\K3MWWVDU\\Liatifis et al. - 2023 - Advancing SDN from OpenFlow to P4 A Survey.pdf:application/pdf},
}

@inproceedings{li_unified_2021,
	title = {A {Unified} {Programming} {Model} over {Heterogeneous} {Data} {Planes}},
	doi = {10.1109/ICCC54389.2021.9674259},
	abstract = {Software Defined Networking (SDN) separates the data plane and the control plane in the traditional network, and the data plane communicates with the control plane through standard protocols. With the development of SDN, there are many southbound communication protocols in academia, such as OpenFlow, Protocol Oblivious Forwarding (POF), Programming protocol-independent packet processors (P4). The design ideas and implementation of these protocols are very different. Therefore, many controllers provide some high-level Application Programming Interfaces (API) supporting different protocols to shield the complexity of the protocol and facilitate the writing of network strategies, but none of them can support different southbound protocols at the runtime. That is, the controller can’t support a variety of different protocols while the data plane has kinds of switches. For example, Open Network Operating System (ONOS) supports P4 and OpenFlow, but it can only support a specific data plane at the runtime, so it cannot combine the strengths and advantages of different types of programmable switches. This paper proposes a unified programming model that can support both the P4 and POF protocols at the runtime so that network users can combine the high performance of the P4 and the flexibility of the POF. We also provide kinds of API to facilitate the writing of network strategies. In certain application scenarios, the losing of data packets caused by updating the data plane pipeline can be effectively eliminated with the programming model.},
	booktitle = {2021 7th {International} {Conference} on {Computer} and {Communications} ({ICCC})},
	author = {Li, Xianhai and Shi, Zhou and Pan, Jiangyu and Tian, Ye},
	month = dec,
	year = {2021},
	keywords = {Pipelines, Protocols, P4, SDN, Computational modeling, heterogeneous data planes, Optical fibers, POF, Programming, programming model, Runtime, Writing},
	pages = {1331--1335},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\ARPM5S8Z\\9674259.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\PS9M2PQG\\Li et al. - 2021 - A Unified Programming Model over Heterogeneous Dat.pdf:application/pdf},
}

@inproceedings{santiago_da_silva_one_2018,
	title = {One for {All}, {All} for {One}: {A} {Heterogeneous} {Data} {Plane} for {Flexible} {P4} {Processing}},
	shorttitle = {One for {All}, {All} for {One}},
	doi = {10.1109/ICNP.2018.00063},
	abstract = {The P4 community has recently put significant effort to increase the diversity of targets on which P4 programs can be implemented. These include fixed function and programmable ASICs, FPGAs, NICs, and CPUs. However, P4 programs are written according to the set of functionalities supported by the target for which they are compiled. For instance, a P4 program targeting a programmable ASIC cannot be extended with user-defined processing modules, which limits the flexibility and the abstraction of P4 programs. To address these shortcomings, we propose a heterogeneous P4 programmable data plane comprised of different targets that together appear as a single logical unit. The proposed data plane broadens the range of functionalities available to P4 programmers by combining the strength of each target. We demonstrate the feasibility of the proposed P4 data plane by coupling an FPGA with a soft switch which emulates a programmable ASIC. The proposed data plane is demonstrated with the implementation of a simplified L2 switch. The emulated ASIC match-table capacity is extended by the FPGA by an order of magnitude.The FPGA also integrates a proprietary module using a P4 extern.},
	booktitle = {2018 {IEEE} 26th {International} {Conference} on {Network} {Protocols} ({ICNP})},
	author = {Santiago da Silva, Jeferson and Stimpfling, Thibaut and Luinaud, Thomas and Fradj, Bachir and Boughzala, Bochra},
	month = sep,
	year = {2018},
	note = {ISSN: 1092-1648},
	keywords = {Lu, Field programmable gate arrays, Pipelines, Protocols, Throughput, Hardware, Couplings, P4, Heterogeneous systems, FPGA, Switches},
	pages = {440--441},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\D9D3JF46\\citations.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\8J7T2VR4\\Santiago da Silva et al. - 2018 - One for All, All for One A Heterogeneous Data Pla.pdf:application/pdf},
}

@misc{sultana_flightplan_2021,
	title = {Flightplan: {Dataplane} {Disaggregation} and {Placement} for {P4} {Programs} - {Blog}},
	shorttitle = {Flightplan},
	url = {https://opennetworking.org/news-and-events/blog/flightplan-dataplane-disaggregation-and-placement-for-p4-programs/},
	abstract = {Introduction The Flightplan project envisages the next generation of dataplane programming tools. It introduces the Dataplane Disaggregation problem—splitting up dataplane programs into program pieces that are mapped to run on different, possibly heterogeneous, network-connected hardware. The choice of splits and hardware is done to optimize network and application objectives beyond what could be achieved than if the original, monolithic […]},
	language = {en-US},
	urldate = {2023-03-27},
	journal = {Open Networking Foundation},
	author = {Sultana, Nik},
	month = apr,
	year = {2021},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\2NH98MX3\\flightplan-dataplane-disaggregation-and-placement-for-p4-programs.html:text/html},
}

@phdthesis{sarbishei_scalable_nodate,
	title = {A scalable high-performance memory-less {IP} address lookup engine suitable for {FPGA} implementation},
	language = {en},
	author = {Sarbishei, Ideh},
	file = {Sarbishei - A scalable high-performance memory-less IP address.pdf:C\:\\Users\\Yann\\Zotero\\storage\\CLUGTEXW\\Sarbishei - A scalable high-performance memory-less IP address.pdf:application/pdf},
}

@phdthesis{noauthor_notitle_nodate,
	type = {M.{A}.{Sc}.},
	file = {Sarbishei - A SCALABLE HIGH-PERFORMANCE MEMORY-LESS IP ADDRESS.pdf:C\:\\Users\\Yann\\Zotero\\storage\\Z7DR6CXI\\Sarbishei - A SCALABLE HIGH-PERFORMANCE MEMORY-LESS IP ADDRESS.pdf:application/pdf},
}

@article{sultana_flightplan_nodate,
	title = {Flightplan: {Dataplane} {Disaggregation} and {Placement} for {P4} {Programs}},
	abstract = {Today’s dataplane programming approach maps a whole P4 program to a single dataplane target, limiting a P4 program’s performance and functionality to what a single target can offer. Disaggregating a single P4 program into subprograms that execute across different dataplanes can improve performance, utilization and cost. But doing this manually is tedious, error-prone and must be repeated as topologies or hardware resources change. We propose Flightplan: a target-agnostic, programming toolchain that helps with splitting a P4 program into a set of cooperating P4 programs and maps them to run as a distributed system formed of several, possibly heterogeneous, dataplanes. Flightplan can exploit features offered by different hardware targets and assists with conﬁguring, testing, and handing-over between dataplanes executing the distributed dataplane program.},
	language = {en},
	author = {Sultana, Nik and Sonchack, John and Giesen, Hans and Pedisich, Isaac and Han, Zhaoyang and Shyamkumar, Nishanth and Burad, Shivani and DeHon, André and Loo, Boon Thau},
	file = {Sultana et al. - Flightplan Dataplane Disaggregation and Placement.pdf:C\:\\Users\\Yann\\Zotero\\storage\\E5QXUPTZ\\Sultana et al. - Flightplan Dataplane Disaggregation and Placement.pdf:application/pdf},
}

@inproceedings{plakalovic_high-speed_2022,
	title = {High-{Speed} {FPGA}-{Based} {Ethernet} {Traffic} {Generator}},
	doi = {10.1109/ICAT54566.2022.9811210},
	abstract = {New generation networks are facing ever greater demands. When testing new network devices that must process packets at extremely high rates, it is essential to test their functionality and desired performance under maximum traffic load. As a result, in order to test the hardware, a traffic generator is required. This paper proposes an affordable and extensible high-speed FPGA-based Ethernet traffic generator. The proposed solution is able of fully utilizing a 40GbE link, with the possibility of manipulating traffic characteristics at the level of an individual packet. Although intended to run on the DE10-Pro system, the proposed design is portable to other FPGA boards with minimal development effort and changes.},
	booktitle = {2022 {XXVIII} {International} {Conference} on {Information}, {Communication} and {Automation} {Technologies} ({ICAT})},
	author = {Plakalovic, Matej and Kaljic, Enio and Mehic, Miralem},
	month = jun,
	year = {2022},
	note = {ISSN: 2643-1858},
	keywords = {FPGA, Generators, Writing, 40GbE, DE10-Pro, Ethernet, Network Tester, Performance evaluation, Systems support, Telecommunication traffic, Traffic Generator, User interfaces},
	pages = {1--6},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\AEBAP57C\\9811210.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\F9CICM4L\\Plakalovic et al. - 2022 - High-Speed FPGA-Based Ethernet Traffic Generator.pdf:application/pdf},
}

@inproceedings{oeldemann_fluent10g_2018,
	title = {{FlueNT10G}: {A} {Programmable} {FPGA}-based {Network} {Tester} for {Multi}-10-{Gigabit} {Ethernet}},
	shorttitle = {{FlueNT10G}},
	doi = {10.1109/FPL.2018.00037},
	abstract = {We present FlueNT10G, an open-source FPGA-based network tester for precise replay of network traces, as well as for accurate packet capture and round-trip latency measurements. FlueNT10G streams replay and capture data between the host system and the FPGA board during active tests. It enables continuous measurements without being constrained by the memory capacity of the FPGA board. FlueNT10G is able to concurrently replay and capture traffic on three 10 Gbit/s network interfaces for all packet sizes. When operated exclusively in replay or capture mode, throughput increases to 4x 10 Gbit/s. Our design yields a temporal resolution of 6.4 ns for precise traffic pattern generation, as well as for accurate arrival timestamping and latency measurements. On the software-side, FlueNT10G is complemented by an API enabling the programmable execution of reproducible network measurements. Targeting the automated performance evaluation of different virtualized network function configurations, the API further integrates access to a bidirectional side-band channel for device-under-test reconfiguration and status feedback. FlueNT10G has been implemented on the NetFPGA-SUME platform (Xilinx Virtex-7 XC7VX690T) with an FPGA resource utilization of no more than 25\%, which leaves sufficient capacity available for future design extensions.},
	booktitle = {2018 28th {International} {Conference} on {Field} {Programmable} {Logic} and {Applications} ({FPL})},
	author = {Oeldemann, Andreas and Wild, Thomas and Herkersdorf, Andreas},
	month = aug,
	year = {2018},
	note = {ISSN: 1946-1488},
	keywords = {Field programmable gate arrays, FPGA, Throughput, Hardware, Performance evaluation, latency measurement, measurement automation, Network interfaces, network tester, Open source software, packet capture, packet generator},
	pages = {178--1787},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\BAMGTNI9\\citations.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\E8S4ZP72\\Oeldemann et al. - 2018 - FlueNT10G A Programmable FPGA-based Network Teste.pdf:application/pdf},
}

@inproceedings{su_fpga-based_2022,
	title = {An {FPGA}-based {HW}/{SW} {Co}-{Verification} {Environment} for {Programmable} {Network} {Devices}},
	doi = {10.1109/ISCAS48785.2022.9937268},
	abstract = {Bugs in network devices translate to financial losses for the service providers and degrade the quality of experience for the users. Simulation tools cannot guarantee complete fault coverage as bugs can manifest at any time in live hardware. To mitigate these issues, we propose a novel hardware/software (HW/SW) co-verification tool that targets programmable dataplane network devices. The system integrates cycle-accurate software simulation with a hardware implementation. For the software simulation, open-source tools such as CocoTB and GHDL were used. The Design Under Test (DUT) and our test interfaces are embedded in programmable hardware. Data from the software can be inserted and then extracted in real-time from the input/output (I/O) ports of the DUT. To achieve this functionality the hardware design uses data insertion and extraction blocks which also support assertions. For the hardware implementation, reported experiments have been conducted on a NetFPGA-SUME platform. When a packet flows through the NetFPGA and triggers an assertion, the data present in the DUT at that time can be captured, and sent back to the simulator for further analysis and replay. Each of our design block consumes less than 1\% of the available resources on the FPGA.},
	booktitle = {2022 {IEEE} {International} {Symposium} on {Circuits} and {Systems} ({ISCAS})},
	author = {Su, Mengyue and David, Jean-Pierre and Savaria, Yvon and Pontikakis, Bill and Luinaud, Thomas},
	month = may,
	year = {2022},
	note = {ISSN: 2158-1525},
	keywords = {FPGA, Software, Hardware, Data mining, User interfaces, bugs, CocoTB, Computer bugs, Coverification, dataplane, NetFPGA, Network testing, on-path telemetry, Real-time systems, Simulation},
	pages = {2529--2533},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\HF78RCQP\\9937268.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\H7ZTRNHG\\Su et al. - 2022 - An FPGA-based HWSW Co-Verification Environment fo.pdf:application/pdf},
}

@article{antichi_osnt_2014,
	title = {{OSNT}: open source network tester},
	volume = {28},
	issn = {1558-156X},
	shorttitle = {{OSNT}},
	doi = {10.1109/MNET.2014.6915433},
	abstract = {Despite network monitoring and testing being critical for computer networks, current solutions are both extremely expensive and inflexible. Into this lacuna we launch the Open Source Network Tester, a fully open source traffic generator and capture system. Our prototype implementation on the NetFPGA-10G supports 4 × 10 Gb/s traffic generation across all packet sizes, and traffic capture is supported up to 2 × 10Gb/s with naïve host software. Our system implementation provides methods for scaling and coordinating multiple generator/capture systems, and supports 6.25 ns timestamp resolution with clock drift and phase coordination maintained by GPS input. Additionally, our approach has demonstrated lower-cost than comparable commercial systems while achieving comparable levels of precision and accuracy; all within an open-source framework extensible with new features to support new applications, while permitting validation and review of the implementation.},
	number = {5},
	journal = {IEEE Network},
	author = {Antichi, Gianni and Shahbaz, Muhammad and Geng, Yilong and Zilberman, Noa and Covington, Adam and Bruyere, Marc and Mckeown, Nick and Feamster, Nick and Felderman, Bob and Blott, Michaela and Moore, Andrew W. and Owezarski, Philippe},
	month = sep,
	year = {2014},
	note = {Conference Name: IEEE Network},
	keywords = {Computer architecture, Monitoring, Open source software, Computer networks, Open systems, Ports (Computers), Testing},
	pages = {6--12},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\5F8QMXXK\\6915433.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\5KKJKFW7\\Antichi et al. - 2014 - OSNT open source network tester.pdf:application/pdf},
}

@inproceedings{hawari_op4t_2021,
	title = {{OP4T}: {Bringing} {Advanced} {Network} {Packet} {Timestamping} into the {Field}},
	shorttitle = {{OP4T}},
	doi = {10.1109/ICOIN50884.2021.9333927},
	abstract = {Because it is very bursty, the microsecond-scale temporal behaviour of network traffic in data-centres is challenging to measure and understand. To bring observability into data-centre networks, this paper introduces the Open Platform for Programmable Precise Packet Timestamping (OP4T), a hardware architecture, targeting Field-Programmable Gateway Arrays (FPGAs), integrated into data-centre servers as a Smart Network Interface Card (SmartNIC), and flexible enough to enable advanced latency diagnosis.In this paper, OP4T is specified, and an open-source implementation of that architecture is proposed, targeting the NetFPGA SUME prototyping board. By leveraging the P4 programming language, and partial reconfiguration, that opensource implementation is experimentally shown to enable in-band, precise packet timestamping, without sacrificing the achievable throughput. As an illustration, OP4T is shown to be usable to measure fine-grained properties of a software packet forwarder, e.g., packet batching.},
	booktitle = {2021 {International} {Conference} on {Information} {Networking} ({ICOIN})},
	author = {Hawari, Mohammed and Clausen, Thomas},
	month = jan,
	year = {2021},
	note = {ISSN: 1976-7684},
	keywords = {Computer architecture, Field programmable gate arrays, Throughput, Network interfaces, Open source software, Computer languages, Software measurement},
	pages = {137--142},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\PXSW7XFM\\9333927.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\CNIPF99Y\\Hawari et Clausen - 2021 - OP4T Bringing Advanced Network Packet Timestampin.pdf:application/pdf},
}

@misc{noauthor_osnt_nodate,
	title = {{OSNT} {SUME} {Home} · {NetFPGA}/{OSNT}-{Public} {Wiki}},
	url = {https://github.com/NetFPGA/OSNT-Public/wiki/OSNT-SUME-Home},
	urldate = {2023-04-04},
}

@misc{noauthor_osnt_nodate-1,
	title = {{OSNT} {SUME} {Getting} {Started} {Guide}},
	url = {https://github.com/NetFPGA/OSNT-Public/wiki/OSNT-SUME-Getting-Started-Guide},
	abstract = {Public Wiki for OSNT. Contribute to NetFPGA/OSNT-Public development by creating an account on GitHub.},
	language = {en},
	urldate = {2023-04-04},
	journal = {GitHub},
}

@misc{noauthor_one-hot_2022,
	title = {One-hot},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=One-hot&oldid=1127084325},
	abstract = {In digital circuits and machine learning, a one-hot is a group of bits among which the legal combinations of values are only those with a single high (1) bit and all the others low (0). A similar implementation in which all bits are '1' except one '0' is sometimes called one-cold. In statistics, dummy variables represent a similar technique for representing categorical data.},
	language = {en},
	urldate = {2023-04-04},
	journal = {Wikipedia},
	month = dec,
	year = {2022},
	note = {Page Version ID: 1127084325},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\I65JCMAR\\One-hot.html:text/html},
}

@misc{noauthor_simple_2023,
	title = {Simple {Network} {Management} {Protocol}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Simple_Network_Management_Protocol&oldid=1146819013},
	abstract = {Simple Network Management Protocol (SNMP) is an Internet Standard protocol for collecting and organizing information about managed devices on IP networks and for modifying that information to change device behaviour. Devices that typically support SNMP include cable modems, routers, switches, servers, workstations, printers, and more.SNMP is widely used in network management for network monitoring.  SNMP exposes management data in the form of variables on the managed systems organized in a management information base (MIB) which describe the system status and configuration. These variables can then be remotely queried (and, in some circumstances, manipulated) by managing applications.
Three significant versions of SNMP have been developed and deployed. SNMPv1 is the original version of the protocol. More recent versions, SNMPv2c and SNMPv3, feature improvements in performance, flexibility and security.
SNMP is a component of the Internet Protocol Suite as defined by the Internet Engineering Task Force (IETF). It consists of a set of standards for network management, including an application layer protocol, a database schema, and a set of data objects.},
	language = {en},
	urldate = {2023-04-05},
	journal = {Wikipedia},
	month = mar,
	year = {2023},
	note = {Page Version ID: 1146819013},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\5PVY4CKF\\Simple_Network_Management_Protocol.html:text/html},
}

@misc{digitalocean_introduction_nodate,
	title = {An {Introduction} to {SNMP} ({Simple} {Network} {Management} {Protocol}) {\textbar} {DigitalOcean}},
	url = {https://www.digitalocean.com/community/tutorials/an-introduction-to-snmp-simple-network-management-protocol},
	abstract = {SNMP, or simple network management protocol, is a standard internet protocol used to monitor remote servers, gather information, and even modify states and v…},
	language = {en},
	urldate = {2023-04-05},
	journal = {DigitalOcean},
	author = {{DigitalOcean}},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\5KJB6GW2\\an-introduction-to-snmp-simple-network-management-protocol.html:text/html},
}

@misc{digitalocean_how_nodate,
	title = {How {To} {Install} and {Configure} an {SNMP} {Daemon} and {Client} on {Ubuntu} 14.04 {\textbar} {DigitalOcean}},
	url = {https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-an-snmp-daemon-and-client-on-ubuntu-14-04},
	abstract = {SNMP is a networking protocol created to as a standard method for managing and monitoring remote systems in your infrastructure. In a previous guide, we dis…},
	language = {en},
	urldate = {2023-04-05},
	journal = {DigitalOcean},
	author = {{DigitalOcean}},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\B5WI59GS\\how-to-install-and-configure-an-snmp-daemon-and-client-on-ubuntu-14-04.html:text/html},
}

@misc{digitalocean_how_nodate-1,
	title = {How {To} {Use} the {Net}-{SNMP} {Tool} {Suite} {To} {Manage} and {Monitor} {Servers} {\textbar} {DigitalOcean}},
	url = {https://www.digitalocean.com/community/tutorials/how-to-use-the-net-snmp-tool-suite-to-manage-and-monitor-servers},
	abstract = {SNMP is a mature network management protocol that can be used to retrieve information and set values on remote systems. In previous guides, we discussed the…},
	language = {en},
	urldate = {2023-04-05},
	journal = {DigitalOcean},
	author = {{DigitalOcean}},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\DQ4Q8IRM\\how-to-use-the-net-snmp-tool-suite-to-manage-and-monitor-servers.html:text/html},
}

@misc{digitalocean_monitoring_nodate,
	title = {Monitoring and {Managing} your {Network} with {SNMP} {\textbar} {DigitalOcean}},
	url = {https://www.digitalocean.com/community/tutorial_series/monitoring-and-managing-your-network-with-snmp},
	abstract = {SNMP, or simple network management protocol, is a well-established way of monitoring and managing diverse sets of networked systems. In this series, we will…},
	language = {en},
	urldate = {2023-04-05},
	journal = {DigitalOcean},
	author = {{DigitalOcean}},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\P98MIAWU\\monitoring-and-managing-your-network-with-snmp.html:text/html},
}

@article{petr_kastovsky_let_2022,
	title = {Let {Your} {Networks} {Soar} with {Intel}® {Tofino}™ {Expandable} {Architecture}¸},
	shorttitle = {Intel® {Tofino}™ {Expandable} {Architecture}¸},
	url = {https://www.intel.com/content/www/us/en/architecture-and-technology/intelligent-fabric/tofino-expandable-architecture-white-paper.html},
	urldate = {2023-04-07},
	collaborator = {{Petr Kastovsky}},
	month = sep,
	year = {2022},
	keywords = {Lu},
	file = {intel-tofino-expandable-architecture-paper.pdf:C\:\\Users\\Yann\\Zotero\\storage\\ZPMWC8DF\\intel-tofino-expandable-architecture-paper.pdf:application/pdf},
}

@inproceedings{yang_using_2022,
	address = {Amsterdam Netherlands},
	title = {Using trio: juniper networks' programmable chipset - for emerging in-network applications},
	isbn = {978-1-4503-9420-8},
	shorttitle = {Using trio},
	url = {https://dl.acm.org/doi/10.1145/3544216.3544262},
	doi = {10.1145/3544216.3544262},
	abstract = {This paper describes Trio, a programmable chipset used in Juniper Networks’ MX-series routers and switches. Trio’s architecture is based on a multi-threaded programmable packet processing engine and a hierarchy of high-capacity memory systems, making it fundamentally different from pipeline-based architectures. Trio gracefully handles non-homogeneous packet processing rates for a wide range of networking use cases and protocols, making it an ideal platform for emerging in-network applications. We begin by describing the Trio chipset’s fundamental building blocks, including its multi-threaded Packet Forwarding and Packet Processing Engines. We then discuss Trio’s programming language, called Microcode. To showcase Trio’s flexible Microcode-based programming environment, we describe two use cases. First, we demonstrate Trio’s ability to perform in-network aggregation for distributed machine learning. Second, we propose and design an in-network straggler mitigation technique using Trio’s timer threads. We prototype both use cases on a testbed using three real DNN models (ResNet50, DenseNet161, and VGG11) to demonstrate Trio’s ability to mitigate stragglers while performing in-network aggregation. Our evaluations show that when stragglers occur in the cluster, Trio outperforms today’s pipeline-based solutions by up to 1.8×.},
	language = {en},
	urldate = {2023-04-11},
	booktitle = {Proceedings of the {ACM} {SIGCOMM} 2022 {Conference}},
	publisher = {ACM},
	author = {Yang, Mingran and Baban, Alex and Kugel, Valery and Libby, Jeff and Mackie, Scott and Kananda, Swamy Sadashivaiah Renu and Wu, Chang-Hong and Ghobadi, Manya},
	month = aug,
	year = {2022},
	keywords = {L1},
	pages = {633--648},
	file = {Yang et al. - 2022 - Using trio juniper networks' programmable chipset.pdf:C\:\\Users\\Yann\\Zotero\\storage\\IDSFSQRT\\Yang et al. - 2022 - Using trio juniper networks' programmable chipset.pdf:application/pdf},
}

@article{noauthor_alveo_2023,
	title = {Alveo {U280} {Data} {Center} {Accelerator} {Card} {Data} {Sheet}},
	abstract = {The AMD Alveo U280 Data Center accelerator card is a full height, dual slot, ¾ length (passive cooling) or full length (active cooling) form factor. It supports PCI Express® Gen3 x16 or Gen4 x8, is equipped with 8 GB of high-bandwidth memory (HBM2), two 16 GB DDR4 RDIMMs operating at 2400 MT/s, and two QSFP28 Ethernet ports capable of 100 Gb/s each. The Alveo U280 card is designed to accelerate memory-bound, compute-intensive applications including database analytics and machine learning inference.},
	language = {en},
	year = {2023},
	file = {2023 - Alveo U280 Data Center Accelerator Card Data Sheet.pdf:C\:\\Users\\Yann\\Zotero\\storage\\6YDYHTUN\\2023 - Alveo U280 Data Center Accelerator Card Data Sheet.pdf:application/pdf},
}

@article{noauthor_alveo_2019,
	title = {Alveo {U280} {Data} {Center} {Accelerator} {Card} {Data} {Sheet}},
	abstract = {The Xilinx® Alveo™ U280 Data Center accelerator card supports PCI Express® Gen3 x16 and Gen4 x8, is equipped with 8 GB high-bandwidth memory (HBM2), and is designed to accelerate memory-bound, compute intensive applications including database analytics and machine learning inference.},
	language = {en},
	year = {2019},
	file = {2019 - Alveo U280 Data Center Accelerator Card Data Sheet.pdf:C\:\\Users\\Yann\\Zotero\\storage\\HE6ZW92P\\2019 - Alveo U280 Data Center Accelerator Card Data Sheet.pdf:application/pdf},
}

@article{noauthor_alveo_2022,
	title = {Alveo {Data} {Center} {Accelerator} {Card} {Platforms}},
	language = {en},
	year = {2022},
	file = {2022 - Alveo Data Center Accelerator Card Platforms.pdf:C\:\\Users\\Yann\\Zotero\\storage\\TZ7W5Y86\\2022 - Alveo Data Center Accelerator Card Platforms.pdf:application/pdf},
}

@article{gozalvez_impact_2012,
	title = {Impact of the radio channel modelling on the performance of {VANET} communication protocols},
	volume = {50},
	issn = {10184864},
	doi = {10.1007/s11235-010-9396-x},
	abstract = {The expected traffic safety and efficiency benefits that can be achieved through the development and deployment of vehicular ad-hoc networks has attracted a significant interest from the networking research community that is currently working on novel vehicular communication protocols. The time-critical nature of vehicular applications and their reliability constraints require a careful protocol design and dimensioning. To this aim, adequate and accurate models should be employed in any research study. One of the critical aspects of any wireless communications system is the radio channel propagation. This is particularly the case in vehicular networks due to their low antenna heights, the fast topology changes and the reliability and latency constraints of traffic safety applications. Despite the research efforts to model the vehicle-to-vehicle communications channel, many networking studies are currently simplifying and even neglecting the radio channel effects on the performance and operation of their protocols. As this work demonstrates, it is critical that realistic and accurate channel models are employed to adequately understand, design and optimize novel vehicular communications and networking protocols.  2010 Springer Science+Business Media, LLC.},
	number = {3},
	journal = {Telecommunication Systems},
	author = {Gozalvez, Javier and Sepulcre, Miguel and Bauza, Ramon},
	year = {2012},
	note = {Publisher: Kluwer Academic Publishers},
	keywords = {Vehicular ad hoc networks, Accident prevention, Antennas, Internet protocols, Radio, Vehicle to vehicle communications},
	pages = {149--167},
	file = {Gozalvez et al. - 2012 - Impact of the radio channel modelling on the perfo.pdf:C\:\\Users\\Yann\\Zotero\\storage\\MPIZ39YU\\Gozalvez et al. - 2012 - Impact of the radio channel modelling on the perfo.pdf:application/pdf},
}

@inproceedings{sommer_applicability_2012,
	title = {On the applicability of {Two}-{Ray} path loss models for vehicular network simulation},
	doi = {10.1109/VNC.2012.6407446},
	abstract = {We discuss the applicability of simplified Two-Ray Ground path loss models to simulation-based performance evaluation studies of Inter-Vehicle Communication (IVC) protocols. We contrast this with the applicability of a more exact Two-Ray Interference model. A key result is that, in most cases, the commonly used simplified Two-Ray Ground models add no additional value compared to the most simple Free-space model - in particular in highway and suburban environments. We further argue that replacing a simplified with a fully featured Two-Ray Interference model can not only substantially improve the accuracy of simulation results but also allow capturing one notable artifact that becomes immediately visible in field tests, namely strong signal attenuation at short and medium ranges. We implemented the Two-ray Interference model within the Veins simulation framework and validated it using analytical predictions and field measurements. We show the impact of the more accurate Two-Ray Interference model, which only comes with negligible additional computational cost for simulation experiments.},
	booktitle = {2012 {IEEE} {Vehicular} {Networking} {Conference} ({VNC})},
	author = {Sommer, Christoph and Joerer, Stefan and Dressler, Falko},
	month = nov,
	year = {2012},
	note = {ISSN: 2157-9865},
	keywords = {Protocols, Computational modeling, Analytical models, Interference, Mathematical model, Predictive models, Receivers},
	pages = {64--69},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\ITSIU3A3\\6407446.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\748WQ4C2\\Sommer et al. - 2012 - On the applicability of Two-Ray path loss models f.pdf:application/pdf},
}

@misc{sommer_two-ray_nodate,
	title = {Two-{Ray} {Interference} {Model}},
	url = {https://veins.car2x.org/documentation/modules/#tworay},
	journal = {The open source vehicular network simulation framework},
	author = {Sommer, Christoph},
}

@article{sommer_using_2011,
	title = {Using the {Right} {Two}-{Ray} {Model}? {A} {Measurement}-based {Evaluation} of {PHY} {Models} in {VANETs}},
	url = {https://www.tkn.tu-berlin.de/bib/sommer2011using/sommer2011using.pdf},
	abstract = {We discuss the feasibility of simpliﬁed Two-Ray Ground path loss models, which are frequently used in simulationbased performance evaluation of Inter-Vehicle Communication (IVC) protocols. We ﬁrst show that these models are of no beneﬁt compared to the basic Freespace model. As an alternative, we propose a more exact Two-Ray Interference model. We substantiate this claim based on an extensive set of measurements on the road. We demonstrate that this model substantially improves the accuracy of the simulation of radio transmissions at negligible computational cost.},
	language = {en},
	number = {3},
	urldate = {2023-05-05},
	author = {Sommer, Christoph and Dressler, Falko},
	year = {2011},
	file = {Gozalvez et al. - 2012 - Impact of the radio channel modelling on the perfo.pdf:C\:\\Users\\Yann\\Zotero\\storage\\W7JNPPFX\\Gozalvez et al. - 2012 - Impact of the radio channel modelling on the perfo.pdf:application/pdf},
}

@article{bose_delineation_1975,
	title = {Delineation of the intimate details of the backbone conformation of pyridine nucleotide coenzymes in aqueous solution},
	volume = {66},
	issn = {1090-2104},
	doi = {10.1016/0006-291x(75)90482-9},
	language = {eng},
	number = {4},
	journal = {Biochemical and Biophysical Research Communications},
	author = {Bose, K. S. and Sarma, R. H.},
	month = oct,
	year = {1975},
	pmid = {2},
	keywords = {Fourier Analysis, Magnetic Resonance Spectroscopy, Models, Molecular, Molecular Conformation, NAD, NADP, Structure-Activity Relationship, Temperature},
	pages = {1173--1179},
	file = {courseVN2023-Module2.pdf:C\:\\Users\\Yann\\Zotero\\storage\\ETBV87LQ\\courseVN2023-Module2.pdf:application/pdf},
}

@misc{cherkaoui_inf6400e_2023,
	title = {{INF6400E} {Lecture} slides, {Modules} \#2 {Use} {Cases}},
	language = {en-US},
	author = {Cherkaoui, Soumaya},
	month = jan,
	year = {2023},
	file = {courseVN2023-Module2.pdf:C\:\\Users\\Yann\\Zotero\\storage\\D6SHNH9K\\courseVN2023-Module2.pdf:application/pdf},
}

@misc{noauthor_openstreetmap_nodate,
	title = {{OpenStreetMap}},
	url = {https://www.openstreetmap.org/},
	abstract = {OpenStreetMap est une carte du monde, créée par des gens comme vous et libre d’utilisation sous licence libre.},
	language = {fr},
	urldate = {2023-05-05},
	journal = {OpenStreetMap},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\9RN44AFV\\www.openstreetmap.org.html:text/html},
}

@misc{intel_powering_nodate,
	title = {Powering {Infrastructure} to {Help} {Shape} the {Data} {Center} of the {Future}},
	author = {{Intel}},
	file = {ipu-baidu-dpu-white-paper.pdf:C\:\\Users\\Yann\\Zotero\\storage\\L7BGSZJJ\\ipu-baidu-dpu-white-paper.pdf:application/pdf},
}

@misc{noauthor_xrt_nodate,
	title = {{XRT} and {Vitis}™ {Platform} {Overview} — {XRT} {Master} documentation},
	url = {https://xilinx.github.io/XRT/master/html/platforms.html},
	urldate = {2023-05-11},
	file = {XRT and Vitis™ Platform Overview — XRT Master documentation:C\:\\Users\\Yann\\Zotero\\storage\\KGKS25P5\\platforms.html:text/html},
}

@article{noauthor_red_nodate,
	title = {Red {Hat} {Enterprise} {Linux} 8 {Configuring} and managing networking},
	abstract = {The networking capabilities of Red Hat Enterprise Linux (RHEL) enable you to configure your host to meet your organization's network and security requirements. You can configure Bonds, VLANs, bridges, tunnels and other network types to connect the host to the network. You can build complex and performance-critical firewalls for the local host and the entire network. Packet filtering software, such as the firewalld service, the nftables framework, and Express Data Path (XDP). RHEL also supports advanced networking features. For example, with policy-based routing, you can set up complex routing scenarios, and MultiPath TCP (MPTCP) enables clients to roam among different networks without interrupting the TCP connection to the application running on your RHEL server.},
	language = {en},
	file = {Red Hat Enterprise Linux 8 Configuring and managin.pdf:C\:\\Users\\Yann\\Zotero\\storage\\WMMXXPCX\\Red Hat Enterprise Linux 8 Configuring and managin.pdf:application/pdf},
}

@article{primorac_how_2017,
	title = {How to {Measure} the {Killer} {Microsecond}},
	volume = {47},
	abstract = {Datacenter-networking research requires tools to both generate traﬃc and accurately measure latency and throughput. While hardware-based tools have long existed commercially, they are primarily used to validate ASICs and lack ﬂexibility, e.g., to study new protocols. They are also too expensive for academics. The recent development of kernel-bypass networking and advanced NIC features such as hardware timestamping have created new opportunities for accurate latency measurements. This paper compares these two approaches, and in particular whether commodity servers and NICs, when properly conﬁgured, can measure the latency distributions as precisely as specialized hardware.},
	language = {en},
	number = {5},
	journal = {ACM SIGCOMM Computer Communication Review},
	author = {Primorac, Mia and Bugnion, Edouard and Argyraki, Katerina},
	year = {2017},
	keywords = {L1},
	file = {Primorac et al. - 2017 - How to Measure the Killer Microsecond.pdf:C\:\\Users\\Yann\\Zotero\\storage\\LXW4T882\\Primorac et al. - 2017 - How to Measure the Killer Microsecond.pdf:application/pdf},
}

@misc{noauthor_network_2023,
	title = {Network function virtualization},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Network_function_virtualization&oldid=1135301873},
	abstract = {Network functions virtualization (NFV) is a network architecture concept that leverages the IT virtualization technologies to virtualize entire classes of network node functions into building blocks that may connect, or chain together, to create and deliver communication services.
NFV relies upon traditional server-virtualization techniques such as those used in enterprise IT. A virtualized network function, or VNF, is implemented within one or more virtual machines or containers running different software and processes, on top of commercial off the shelf (COTS) high-volume servers, switches and storage devices, or even cloud computing infrastructure, instead of having custom hardware appliances for each network function thereby avoiding vendor lock-in.
For example, a virtual session border controller could be deployed to protect a network without the typical cost and complexity of obtaining and installing physical network protection units. Other examples of NFV include virtualized load balancers, firewalls, intrusion detection devices and WAN accelerators to name a few.The decoupling of the network function software from the customized hardware platform realizes a flexible network architecture that enables agile network management, fast new service roll outs with significant reduction in CAPEX and OPEX.},
	language = {en},
	urldate = {2023-05-29},
	journal = {Wikipedia},
	month = jan,
	year = {2023},
	note = {Page Version ID: 1135301873},
	keywords = {L1},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\7FCJQW3N\\Network_function_virtualization.html:text/html},
}

@misc{noauthor_5g_2023,
	title = {{5G} network slicing},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=5G_network_slicing&oldid=1153919039},
	abstract = {5G network slicing is a network architecture that enables the multiplexing of virtualized and independent logical networks on the same physical network infrastructure. Each network slice is an isolated end-to-end network tailored to fulfil diverse requirements requested by a particular application.For this reason, this technology assumes a central role to support 5G mobile networks that are designed to efficiently embrace a plethora of services with very different service level requirements (SLR). The realization of this service-oriented view of the network leverages on the concepts of software-defined networking (SDN) and network function virtualization (NFV) that allow the implementation of flexible and scalable network slices on top of a common network infrastructure.From a business model perspective, each network slice is administrated by a mobile virtual network operator (MVNO). The infrastructure provider (the owner of the telecommunication infrastructure) leases its physical resources to the MVNOs that share the underlying physical network. According to the availability of the assigned resources, a MVNO can autonomously deploy multiple network slices that are customized to the various applications provided to its own users.},
	language = {en},
	urldate = {2023-05-29},
	journal = {Wikipedia},
	month = may,
	year = {2023},
	note = {Page Version ID: 1153919039},
	keywords = {L1},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\HR5AZ6N6\\5G_network_slicing.html:text/html},
}

@inproceedings{forencich_corundum_2020,
	title = {Corundum: {An} {Open}-{Source} 100-{Gbps} {Nic}},
	shorttitle = {Corundum},
	doi = {10.1109/FCCM48280.2020.00015},
	abstract = {Corundum is an open-source, FPGA-based prototyping platform for network interface development at up to 100 Gbps and beyond. The Corundum platform includes several core features to enable real-time, high-line-rate operations including: a high-performance datapath, 10G/25G/100G Ethernet MACs, PCI Express gen 3, a custom PCIe DMA engine, and native high-precision IEEE 1588 PTP timestamping. A key feature is extensible queue management that can support over 10,000 queues coupled with extensible transmit schedulers, enabling fine-grained hardware control of packet transmission. In conjunction with multiple network interfaces, multiple ports per interface, and per-port event-driven transmit scheduling, these features enable the development of advanced network interfaces, architectures, and protocols. The software interface to these hardware features is a high-performance driver for the Linux networking stack. The platform also supports scatter/gather DMA, checksum offloading, receive flow hashing, and receive-side scaling. Development and debugging is facilitated by a comprehensive open-source, Python-based simulation framework that includes the entire system from a simulation model of the driver and PCI express interface to the Ethernet interfaces. The power and flexibility of Corundum is demonstrated by the implementation of a microsecond-precision time-division multiple access (TDMA) hardware scheduler to enforce a TDMA schedule at 100 Gbps line rate with no CPU overhead.},
	booktitle = {2020 {IEEE} 28th {Annual} {International} {Symposium} on {Field}-{Programmable} {Custom} {Computing} {Machines} ({FCCM})},
	author = {Forencich, Alex and Snoeren, Alex C. and Porter, George and Papen, George},
	month = may,
	year = {2020},
	note = {ISSN: 2576-2621},
	keywords = {Protocols, Hardware, L1, Ethernet, Real-time systems, Ports (computers), Schedules, Time division multiple access},
	pages = {38--46},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\FP4S3W5N\\9114811.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\E4YG2UXC\\Forencich et al. - 2020 - Corundum An Open-Source 100-Gbps Nic.pdf:application/pdf},
}

@misc{noauthor_time-division_2022,
	title = {Time-division multiple access},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Time-division_multiple_access&oldid=1085624106},
	abstract = {Time-division multiple access (TDMA) is a channel access method for shared-medium networks. It allows several users to share the same frequency channel by dividing the signal into different time slots. The users transmit in rapid succession, one after the other, each using its own time slot.  This allows multiple stations to share the same transmission medium (e.g. radio frequency channel) while using only a part of its channel capacity. Dynamic TDMA is a TDMA variant that dynamically reserves a variable number of time slots in each frame to variable bit-rate data streams, based on the traffic demand of each data stream.
TDMA is used in the digital 2G cellular systems such as Global System for Mobile Communications (GSM), IS-136, Personal Digital Cellular (PDC) and iDEN, and in the Digital Enhanced Cordless Telecommunications (DECT) standard for portable phones. TDMA was first used in satellite communication systems by Western Union in its Westar 3 communications satellite in 1979. It is now used extensively in satellite communications, combat-net radio systems, and passive optical network (PON) networks for upstream traffic from premises to the operator.
TDMA is a type of time-division multiplexing (TDM), with the special point that instead of having one transmitter connected to one receiver, there are multiple transmitters. In the case of the uplink from a mobile phone to a base station this becomes particularly difficult because the mobile phone can move around and vary the timing advance required to make its transmission match the gap in transmission from its peers.},
	language = {en},
	urldate = {2023-06-01},
	journal = {Wikipedia},
	month = may,
	year = {2022},
	note = {Page Version ID: 1085624106},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\9KL9BI5M\\Time-division_multiple_access.html:text/html},
}

@misc{noauthor_core_2023,
	title = {Core dump},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Core_dump&oldid=1157626885},
	abstract = {In computing, a core dump, memory dump, crash dump, storage dump, system dump, or ABEND dump consists of the recorded state of the working memory of a computer program at a specific time, generally when the program has crashed or otherwise terminated abnormally.  In practice, other key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and other processor and operating system flags and information. A snapshot  dump (or snap dump) is a memory dump requested by the computer operator or by the running program, after which the program is able to continue. Core dumps are often used to assist in diagnosing and debugging errors in computer programs.
On many operating systems, a fatal exception in a program automatically triggers a core dump. By extension, the phrase "to dump core" has come to mean in many cases, any fatal error, regardless of whether a record of the program memory exists.  The term "core dump", "memory dump", or just "dump" has also become jargon to indicate any output of a large amount of raw data for further examination or other purposes.},
	language = {en},
	urldate = {2023-06-02},
	journal = {Wikipedia},
	month = may,
	year = {2023},
	note = {Page Version ID: 1157626885},
	keywords = {Lu partiellement},
}

@misc{noauthor_memory_2023,
	title = {Memory segmentation},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Memory_segmentation&oldid=1150592683},
	abstract = {Memory segmentation is an operating system memory management technique of dividing a computer's primary memory into segments or sections. In a computer system using segmentation, a reference to a memory location includes a value that identifies a segment and an offset (memory location) within that segment. Segments or sections are also used in object files of compiled programs when they are linked together into a program image and when the image is loaded into memory.
Segments usually correspond to natural divisions of a program such as individual routines or data tables so segmentation is generally more visible to the programmer than paging alone. Segments may be created for program modules, or for classes of memory usage such as code segments and data segments. Certain segments may be shared between programs.Segmentation was originally invented as a method by which system software could isolate software processes (tasks) and data they are using. It was intended to increase reliability of the systems running multiple processes simultaneously.},
	language = {en},
	urldate = {2023-06-02},
	journal = {Wikipedia},
	month = apr,
	year = {2023},
	note = {Page Version ID: 1150592683},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\5VYKB5W3\\Memory_segmentation.html:text/html},
}

@book{patterson_computer_2017,
	address = {Amsterdam ; Boston},
	edition = {ARM® edition},
	title = {Computer organization and design: the hardware/software interface},
	isbn = {978-0-12-801733-3},
	shorttitle = {Computer organization and design},
	abstract = {This book presents the fundamentals of hardware technologies, assembly language, computer arithmetic, pipelining, memory hierarchies and I/O. This edition is updated for mobile computing and the cloud!},
	publisher = {Elsevier/Morgan Kaufmann},
	author = {Patterson, David A. and Hennessy, John L. and Alexander, Perry},
	year = {2017},
	note = {OCLC: ocn946041146},
	keywords = {Lu, Computer architecture, Computer organization, Data processing, System design},
	annote = {Computer abstractions and technology -- Instructions : language of the computer -- Arithmetic for computers -- The processor -- Large and fast : exploiting memory hierarchy -- Parallel processors from client to cloud},
	file = {Section 6.9 - Computer Organization and Design ARM edition.pdf:C\:\\Users\\Yann\\Zotero\\storage\\8RTYPP6P\\Section 6.9 - Computer Organization and Design ARM edition.pdf:application/pdf},
}

@misc{noauthor_precision_2023,
	title = {Precision {Time} {Protocol}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://fr.wikipedia.org/w/index.php?title=Precision_Time_Protocol&oldid=200140905},
	abstract = {Le Precision Time Protocol (PTP) est un protocole utilisé pour synchroniser les signaux d'horloge des différents éléments d'un réseau, par exemple un réseau Ethernet. Il a été normalisé par l'Internet Engineering Task Force sous le nom d'IEEE-1588 en 2002 et a été modifié en juin 2008 (version 2) et en novembre 2019 (version 3). La Commission électrotechnique internationale lui donne le nom d'IEC 61588.  
Le PTP n'a pas vocation à déterminer un horodatage, mais à le transmettre. Tout système PTP doit donc intégrer ou se baser sur une source de temps, par exemple une horloge GPS, et s'y recaler régulièrement. La synchronisation est obtenue avec une précision typiquement inférieure à la microseconde, la limite théorique étant d'une nanoseconde. 
Il a été développé afin de fournir une alternative au protocole Network Time Protocol (NTP) et au transfert d'informations temporelles par satellite (par exemple par Global Positioning System (GPS)). Le protocole NTP n'est pas assez précis pour de nombreuses applications. Quant au GPS, il est difficile à mettre en place sur un réseau, chaque élément de réseau devant être équipé d'un récepteur ayant accès à des signaux de bonne qualité.},
	language = {fr},
	urldate = {2023-06-05},
	journal = {Wikipédia},
	month = jan,
	year = {2023},
	note = {Page Version ID: 200140905},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\YDH7ALIZ\\Precision_Time_Protocol.html:text/html},
}

@article{adeleke_network_2023,
	title = {Network {Traffic} {Generation}: {A} {Survey} and {Methodology}},
	volume = {55},
	issn = {0360-0300, 1557-7341},
	shorttitle = {Network {Traffic} {Generation}},
	url = {https://dl.acm.org/doi/10.1145/3488375},
	doi = {10.1145/3488375},
	abstract = {Network traffic workloads are widely utilized in applied research to verify correctness and to measure the impact of novel algorithms, protocols, and network functions. We provide a comprehensive survey of traffic generators referenced by researchers over the last 13 years, providing in-depth classification of the functional behaviors of the most frequently cited generators. These classifications are then used as a critical component of a methodology presented to aid in the selection of generators derived from the workload requirements of future research.},
	language = {en},
	number = {2},
	urldate = {2023-06-05},
	journal = {ACM Computing Surveys},
	author = {Adeleke, Oluwamayowa Ade and Bastin, Nicholas and Gurkan, Deniz},
	month = feb,
	year = {2023},
	keywords = {L1},
	pages = {1--23},
	file = {Adeleke et al. - 2023 - Network Traffic Generation A Survey and Methodolo.pdf:C\:\\Users\\Yann\\Zotero\\storage\\RK7Q3AUF\\Adeleke et al. - 2023 - Network Traffic Generation A Survey and Methodolo.pdf:application/pdf},
}

@article{firestone_azure_nodate,
	title = {Azure {Accelerated} {Networking}: {SmartNICs} in the {Public} {Cloud}},
	language = {en},
	author = {Firestone, Daniel and Putnam, Andrew and Mundkur, Sambhrama and Chiou, Derek and Dabagh, Alireza and Andrewartha, Mike and Angepat, Hari and Bhanu, Vivek and Caulﬁeld, Adrian and Chung, Eric and Chandrappa, Harish Kumar and Chaturmohta, Somesh and Humphrey, Matt and Lavier, Jack and Lam, Norman and Liu, Fengfen and Ovtcharov, Kalin and Padhye, Jitu and Popuri, Gautham and Raindel, Shachar and Sapre, Tejas and Shaw, Mark and Silva, Gabriel and Sivakumar, Madhan and Srivastava, Nisheeth and Verma, Anshuman and Zuhair, Qasim and Bansal, Deepak and Burger, Doug and Vaid, Kushagra and Maltz, David A and Greenberg, Albert},
}

@inproceedings{firestone_azure_2018,
	address = {USA},
	series = {{NSDI}'18},
	title = {Azure accelerated networking: {SmartNICs} in the public cloud},
	isbn = {978-1-931971-43-0},
	shorttitle = {Azure accelerated networking},
	url = {https://www.usenix.org/system/files/conference/nsdi18/nsdi18-firestone.pdf},
	abstract = {Modern cloud architectures rely on each server running its own networking stack to implement policies such as tunneling for virtual networks, security, and load balancing. However, these networking stacks are becoming increasingly complex as features are added and as network speeds increase. Running these stacks on CPU cores takes away processing power from VMs, increasing the cost of running cloud services, and adding latency and variability to network performance. We present Azure Accelerated Networking (AccelNet), our solution for offloading host networking to hardware, using custom Azure SmartNICs based on FPGAs. We define the goals of AccelNet, including programmability comparable to software, and performance and efficiency comparable to hardware. We show that FPGAs are the best current platform for offloading our networking stack as ASICs do not provide sufficient programmability, and embedded CPU cores do not provide scalable performance, especially on single network flows. Azure SmartNICs implementing AccelNet have been deployed on all new Azure servers since late 2015 in a fleet of {\textgreater}1M hosts. The AccelNet service has been available for Azure customers since 2016, providing consistent {\textless}15µs VM-VM TCP latencies and 32Gbps throughput, which we believe represents the fastest network available to customers in the public cloud. We present the design of AccelNet, including our hardware/software codesign model, performance results on key workloads, and experiences and lessons learned from developing and deploying AccelNet on FPGA-based Azure SmartNICs.},
	urldate = {2023-06-06},
	booktitle = {Proceedings of the 15th {USENIX} {Conference} on {Networked} {Systems} {Design} and {Implementation}},
	publisher = {USENIX Association},
	author = {Firestone, Daniel and Putnam, Andrew and Mundkur, Sambhrama and Chiou, Derek and Dabagh, Alireza and Andrewartha, Mike and Angepat, Hari and Bhanu, Vivek and Caulfield, Adrian and Chung, Eric and Chandrappa, Harish Kumar and Chaturmohta, Somesh and Humphrey, Matt and Lavier, Jack and Lam, Norman and Liu, Fengfen and Ovtcharov, Kalin and Padhye, Jitu and Popuri, Gautham and Raindel, Shachar and Sapre, Tejas and Shaw, Mark and Silva, Gabriel and Sivakumar, Madhan and Srivastava, Nisheeth and Verma, Anshuman and Zuhair, Qasim and Bansal, Deepak and Burger, Doug and Vaid, Kushagra and Maltz, David A. and Greenberg, Albert},
	month = apr,
	year = {2018},
	keywords = {L1},
	pages = {51--64},
	file = {Firestone et al. - Azure Accelerated Networking SmartNICs in the Pub.pdf:C\:\\Users\\Yann\\Zotero\\storage\\WT54C2WF\\Firestone et al. - Azure Accelerated Networking SmartNICs in the Pub.pdf:application/pdf},
}

@inproceedings{emmerich_moongen_2015,
	address = {Tokyo Japan},
	title = {{MoonGen}: {A} {Scriptable} {High}-{Speed} {Packet} {Generator}},
	isbn = {978-1-4503-3848-6},
	shorttitle = {{MoonGen}},
	url = {https://dl.acm.org/doi/10.1145/2815675.2815692},
	doi = {10.1145/2815675.2815692},
	abstract = {We present MoonGen, a ﬂexible high-speed packet generator. It can saturate 10 GbE links with minimum-sized packets while using only a single CPU core by running on top of the packet processing framework DPDK. Linear multicore scaling allows for even higher rates: We have tested MoonGen with up to 178.5 Mpps at 120 Gbit/s. Moving the whole packet generation logic into user-controlled Lua scripts allows us to achieve the highest possible ﬂexibility. In addition, we utilize hardware features of commodity NICs that have not been used for packet generators previously. A key feature is the measurement of latency with sub-microsecond precision and accuracy by using hardware timestamping capabilities of modern commodity NICs. We address timing issues with software-based packet generators and apply methods to mitigate them with both hardware support and with a novel method to control the inter-packet gap in software. Features that were previously only possible with hardware-based solutions are now provided by MoonGen on commodity hardware. MoonGen is available as free software under the MIT license in our git repository at https://github.com/emmericp/MoonGen.},
	language = {en},
	urldate = {2023-06-08},
	booktitle = {Proceedings of the 2015 {Internet} {Measurement} {Conference}},
	publisher = {ACM},
	author = {Emmerich, Paul and Gallenmüller, Sebastian and Raumer, Daniel and Wohlfart, Florian and Carle, Georg},
	month = oct,
	year = {2015},
	keywords = {L1},
	pages = {275--287},
	file = {Emmerich et al. - 2015 - MoonGen A Scriptable High-Speed Packet Generator.pdf:C\:\\Users\\Yann\\Zotero\\storage\\VY8KCFI7\\Emmerich et al. - 2015 - MoonGen A Scriptable High-Speed Packet Generator.pdf:application/pdf},
}

@inproceedings{bressana_programmable_2018,
	address = {Budapest Hungary},
	title = {A {Programmable} {Framework} for {Validating} {Data} {Planes}},
	isbn = {978-1-4503-5915-3},
	url = {https://dl.acm.org/doi/10.1145/3234200.3234220},
	doi = {10.1145/3234200.3234220},
	abstract = {Due to the emerging trend of programmable network hardware, developers have begun to explore ways to accelerate various applications and services. As a result, there is a pressing need for new tools and techniques for debugging network devices. This paper presents NetDebug, a fully programmable hardware-software framework for validating and real-time debugging of programmable data planes. We describe validation use cases, compare our design to alternative solutions, and present a preliminary evaluation using a prototype implementation.},
	language = {en},
	urldate = {2023-06-08},
	booktitle = {Proceedings of the {ACM} {SIGCOMM} 2018 {Conference} on {Posters} and {Demos}},
	publisher = {ACM},
	author = {Bressana, Pietro and Zilberman, Noa and Soulé, Robert},
	month = aug,
	year = {2018},
	keywords = {L1},
	pages = {1--3},
	file = {Bressana et al. - 2018 - A Programmable Framework for Validating Data Plane.pdf:C\:\\Users\\Yann\\Zotero\\storage\\VAYTZL8X\\Bressana et al. - 2018 - A Programmable Framework for Validating Data Plane.pdf:application/pdf},
}

@inproceedings{harkous_performance_2021,
	address = {Espoo and Helsinki, Finland},
	title = {Performance {Study} of {P4} {Programmable} {Devices}: {Flow} {Scalability} and {Rule} {Update} {Responsiveness}},
	isbn = {978-3-903176-39-3},
	shorttitle = {Performance {Study} of {P4} {Programmable} {Devices}},
	url = {https://ieeexplore.ieee.org/document/9472782/},
	doi = {10.23919/IFIPNetworking52078.2021.9472782},
	abstract = {Networking devices with programmable data planes, such as P4 programmable devices, are gaining more popularity because of the ﬂexibility they provide in describing the packet processing behavior. Despite this attained ﬂexibility, the performance of these devices can be the Achilles’ heel in case the desired performance level is not met.},
	language = {en},
	urldate = {2023-06-08},
	booktitle = {2021 {IFIP} {Networking} {Conference} ({IFIP} {Networking})},
	publisher = {IEEE},
	author = {Harkous, Hasanin and He, Mu and Jarschel, Michael and Pries, Rastin and Mansour, Ehab and Kellerer, Wolfgang},
	month = jun,
	year = {2021},
	pages = {1--6},
	file = {Harkous et al. - 2021 - Performance Study of P4 Programmable Devices Flow.pdf:C\:\\Users\\Yann\\Zotero\\storage\\Q8XV3SS3\\Harkous et al. - 2021 - Performance Study of P4 Programmable Devices Flow.pdf:application/pdf},
}

@inproceedings{kundel_p4sta_2020,
	address = {Budapest, Hungary},
	title = {{P4STA}: {High} {Performance} {Packet} {Timestamping} with {Programmable} {Packet} {Processors}},
	isbn = {978-1-72814-973-8},
	shorttitle = {{P4STA}},
	url = {https://ieeexplore.ieee.org/document/9110290/},
	doi = {10.1109/NOMS47738.2020.9110290},
	abstract = {QoS requirements of current network control and management applications require the ability to conduct precise measurements of network elements, including switches, routers and Virtual Network Functions (VNFs). State-of-the-art network switches have a forwarding delay of 1µs and below and offer high bandwidths of hundreds Gigabits per second. This imposes high time accuracy and loss-detection requirements on measurement equipment that are not met by existing, software-based measurement tools. The use of specialized tools, meeting these requirements, is restricted by limited ﬂexibility and high cost.},
	language = {en},
	urldate = {2023-06-08},
	booktitle = {{NOMS} 2020 - 2020 {IEEE}/{IFIP} {Network} {Operations} and {Management} {Symposium}},
	publisher = {IEEE},
	author = {Kundel, Ralf and Siegmund, Fridolin and Blendin, Jeremias and Rizk, Amr and Koldehofe, Boris},
	month = apr,
	year = {2020},
	pages = {1--9},
	file = {Kundel et al. - 2020 - P4STA High Performance Packet Timestamping with P.pdf:C\:\\Users\\Yann\\Zotero\\storage\\HIDKUDG5\\Kundel et al. - 2020 - P4STA High Performance Packet Timestamping with P.pdf:application/pdf},
}

@misc{noauthor_gatherscatter_nodate,
	title = {Gather/scatter (vector addressing) - {Wikipedia}},
	url = {https://en.wikipedia.org/wiki/Gather/scatter_(vector_addressing)},
	urldate = {2023-06-15},
	keywords = {Lu},
	file = {Gather/scatter (vector addressing) - Wikipedia:C\:\\Users\\Yann\\Zotero\\storage\\BGCS34VI\\scatter_(vector_addressing).html:text/html},
}

@incollection{hennessy_interconnection_2019,
	address = {Cambridge, MA},
	edition = {Sixth edition},
	title = {Interconnection {Networks}},
	isbn = {978-0-12-811905-1},
	booktitle = {Computer architecture: a quantitative approach},
	publisher = {Morgan Kaufmann Publishers},
	author = {Hennessy, John L.},
	year = {2019},
	keywords = {Computer architecture},
	file = {Interconnection Networks - Hennessy & Patterson - Annexe F.pdf:C\:\\Users\\Yann\\Zotero\\storage\\46MPSDK7\\Interconnection Networks - Hennessy & Patterson - Annexe F.pdf:application/pdf},
}

@article{harvey_dma_nodate,
	title = {{DMA} {Fundamentals} on {Various} {PC} {Platforms}},
	language = {en},
	journal = {App Note National Instruments},
	author = {Harvey, A F},
	file = {Harvey - DMA Fundamentals on Various PC Platforms.pdf:C\:\\Users\\Yann\\Zotero\\storage\\5STEJDWD\\Harvey - DMA Fundamentals on Various PC Platforms.pdf:application/pdf},
}

@misc{noauthor_circular_2023,
	title = {Circular buffer},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Circular_buffer&oldid=1154573256},
	abstract = {In computer science, a circular buffer, circular queue, cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure lends itself easily to buffering data streams. There were early circular buffer implementations in hardware.},
	language = {en},
	urldate = {2023-06-16},
	journal = {Wikipedia},
	month = may,
	year = {2023},
	note = {Page Version ID: 1154573256},
	keywords = {Lu, Survolé},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\7YJ5DXM4\\Circular_buffer.html:text/html},
}

@misc{wada_ring_2013,
	title = {Ring {Buffer} {Basics}},
	url = {https://www.embedded.com/ring-buffer-basics/},
	abstract = {Embedded.com Explores The Ring Buffer (or Circular Buffer) in C, Design Features, and Offers Practical Examples. Visit Today To Learn More.},
	language = {en-US},
	urldate = {2023-06-19},
	journal = {Embedded.com},
	author = {Wada, Ken},
	month = aug,
	year = {2013},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\YD595DH8\\ring-buffer-basics.html:text/html},
}

@misc{dan_guisselquist_learning_2022,
	title = {Learning {AXI}: {Where} to start?},
	url = {http://zipcpu.com/blog/2022/05/07/learning-axi.html},
	urldate = {2023-06-21},
	journal = {ZipCPU},
	author = {{Dan Guisselquist}},
	month = may,
	year = {2022},
	keywords = {L1},
	file = {Learning AXI\: Where to start?:C\:\\Users\\Yann\\Zotero\\storage\\GFAEVBHY\\learning-axi.html:text/html},
}

@misc{dan_guisselquist_building_2019,
	title = {Building a custom yet functional {AXI}-lite slave},
	url = {http://zipcpu.com/blog/2019/01/12/demoaxilite.html},
	urldate = {2023-06-21},
	journal = {ZipCPU},
	author = {{Dan Guisselquist}},
	month = jan,
	year = {2019},
	file = {Building a custom yet functional AXI-lite slave:C\:\\Users\\Yann\\Zotero\\storage\\CXT5ZIJX\\demoaxilite.html:text/html},
}

@misc{dan_guisselquist_using_2018,
	title = {Using a formal property file to verify an {AXI}-lite peripheral},
	url = {http://zipcpu.com/formal/2018/12/28/axilite.html},
	urldate = {2023-06-21},
	journal = {ZipCPU},
	author = {{Dan Guisselquist}},
	month = dec,
	year = {2018},
	keywords = {Lu partiellement},
	file = {Using a formal property file to verify an AXI-lite peripheral:C\:\\Users\\Yann\\Zotero\\storage\\GMWQB2R3\\axilite.html:text/html},
}

@misc{dan_guisselquist_axi_2021,
	title = {{AXI} {Handshaking} {Rules}},
	url = {http://zipcpu.com/blog/2021/08/28/axi-rules.html},
	urldate = {2023-06-21},
	journal = {ZipCPU},
	author = {{Dan Guisselquist}},
	month = aug,
	year = {2021},
	keywords = {Lu},
	file = {AXI Handshaking Rules:C\:\\Users\\Yann\\Zotero\\storage\\WNET9BS8\\axi-rules.html:text/html},
}
