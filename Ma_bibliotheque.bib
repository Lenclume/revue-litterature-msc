
@misc{parol_p4_2020,
	title = {P4 {Network} {Programming} {Language}—what is it all about?},
	url = {https://codilime.com/blog/p4-network-programming-language-what-is-it-all-about/},
	abstract = {P4 is a programming language that can be used to program network devices. Read on to learn more on its history, architecture and use cases.},
	language = {en-us},
	urldate = {2023-01-18},
	journal = {CodiLime},
	author = {Parol, Pawel},
	month = apr,
	year = {2020},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\4JMF8XCM\\p4-network-programming-language-what-is-it-all-about.html:text/html},
}

@misc{noauthor_what_2022,
	title = {What you should know about {P4} programming language\& {P4} programmable switch},
	url = {https://cloudswit.ch/blogs/what-you-should-know-about-p4-programming-language-p4-switch/},
	abstract = {This article is an explanation of what is P4 programming language\& P4 switch. Further introduces Asterfusion Tofino based 3.3T-6.5T P4 programmable switch solutions},
	language = {en-US},
	urldate = {2023-01-18},
	journal = {Open Source Software Defined Network},
	month = jan,
	year = {2022},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\KL9P32VV\\what-you-should-know-about-p4-programming-language-p4-switch.html:text/html},
}

@misc{rijsman_getting_2019,
	title = {Getting {Started} with {P4}},
	url = {https://opennetworking.org/news-and-events/blog/getting-started-with-p4/},
	abstract = {Editor Note: This post was originally written by Bruno Rijsman for his personal blog. We are re-publishing it here (with permission) as it provides an excellent introduction to getting started with the P4 language using the software tools that have been developed by the open-source community. Introduction I recently got serious about learning P4, a […]},
	language = {en-US},
	urldate = {2023-01-18},
	journal = {Open Networking Foundation},
	author = {Rijsman, Bruno},
	month = oct,
	year = {2019},
	keywords = {Lu, Tutoriel},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\KE2ZQHAN\\getting-started-with-p4.html:text/html},
}

@article{bosshart_p4_2014,
	title = {P4: programming protocol-independent packet processors},
	volume = {44},
	issn = {0146-4833},
	shorttitle = {P4},
	url = {https://dl.acm.org/doi/10.1145/2656877.2656890},
	doi = {10.1145/2656877.2656890},
	abstract = {P4 is a high-level language for programming protocol-independent packet processors. P4 works in conjunction with SDN control protocols like OpenFlow. In its current form, OpenFlow explicitly speciﬁes protocol headers on which it operates. This set has grown from 12 to 41 ﬁelds in a few years, increasing the complexity of the speciﬁcation while still not providing the ﬂexibility to add new headers. In this paper we propose P4 as a strawman proposal for how OpenFlow should evolve in the future. We have three goals: (1) Reconﬁgurability in the ﬁeld: Programmers should be able to change the way switches process packets once they are deployed. (2) Protocol independence: Switches should not be tied to any speciﬁc network protocols. (3) Target independence: Programmers should be able to describe packetprocessing functionality independently of the speciﬁcs of the underlying hardware. As an example, we describe how to use P4 to conﬁgure a switch to add a new hierarchical label.},
	language = {en},
	number = {3},
	urldate = {2023-01-24},
	journal = {ACM SIGCOMM Computer Communication Review},
	author = {Bosshart, Pat and Daly, Dan and Gibb, Glen and Izzard, Martin and McKeown, Nick and Rexford, Jennifer and Schlesinger, Cole and Talayco, Dan and Vahdat, Amin and Varghese, George and Walker, David},
	month = jul,
	year = {2014},
	keywords = {Lu},
	pages = {87--95},
	file = {Bosshart et al. - 2014 - P4 programming protocol-independent packet proces.pdf:C\:\\Users\\Yann\\Zotero\\storage\\K7B89BDF\\Bosshart et al. - 2014 - P4 programming protocol-independent packet proces.pdf:application/pdf},
}

@article{michel_programmable_2022,
	title = {The {Programmable} {Data} {Plane}: {Abstractions}, {Architectures}, {Algorithms}, and {Applications}},
	volume = {54},
	issn = {0360-0300, 1557-7341},
	shorttitle = {The {Programmable} {Data} {Plane}},
	url = {http://arxiv.org/abs/2110.00631},
	doi = {10.1145/3447868},
	abstract = {Programmable data plane technology enables the systematic reconfiguration of the low-level processing steps applied to network packets and is a key driver in realizing the next generation of network services and applications. This survey presents recent trends and issues in the design and implementation of programmable network devices, focusing on prominent architectures, abstractions, algorithms, and applications proposed, debated, and realized over the past years. We elaborate on the trends that led to the emergence of this technology and highlight the most important pointers from the literature, casting different taxonomies for the field and identifying avenues for future research.},
	language = {en},
	number = {4},
	urldate = {2023-01-24},
	journal = {ACM Computing Surveys},
	author = {Michel, Oliver and Bifulco, Roberto and Retvari, Gabor and Schmid, Stefan},
	month = may,
	year = {2022},
	note = {arXiv:2110.00631 [cs]},
	keywords = {Computer Science - Networking and Internet Architecture},
	pages = {1--36},
	file = {Michel et al. - 2022 - The Programmable Data Plane Abstractions, Archite.pdf:C\:\\Users\\Yann\\Zotero\\storage\\6AIVRSXF\\Michel et al. - 2022 - The Programmable Data Plane Abstractions, Archite.pdf:application/pdf},
}

@article{kfoury_exhaustive_2021,
	title = {An {Exhaustive} {Survey} on {P4} {Programmable} {Data} {Plane} {Switches}: {Taxonomy}, {Applications}, {Challenges}, and {Future} {Trends}},
	volume = {9},
	issn = {2169-3536},
	shorttitle = {An {Exhaustive} {Survey} on {P4} {Programmable} {Data} {Plane} {Switches}},
	url = {https://ieeexplore.ieee.org/document/9447791/},
	doi = {10.1109/ACCESS.2021.3086704},
	abstract = {Traditionally, the data plane has been designed with fixed functions to forward packets using a small set of protocols. This closed-design paradigm has limited the capability of the switches to proprietary implementations which are hard-coded by vendors, inducing a lengthy, costly, and inflexible process. Recently, data plane programmability has attracted significant attention from both the research community and the industry, permitting operators and programmers in general to run customized packet processing functions. This open-design paradigm is paving the way for an unprecedented wave of innovation and experimentation by reducing the time of designing, testing, and adopting new protocols; enabling a customized, top-down approach to develop network applications; providing granular visibility of packet events defined by the programmer; reducing complexity and enhancing resource utilization of the programmable switches; and drastically improving the performance of applications that are offloaded to the data plane. Despite the impressive advantages of programmable data plane switches and their importance in modern networks, the literature has been missing a comprehensive survey. To this end, this paper provides a background encompassing an overview of the evolution of networks from legacy to programmable, describing the essentials of programmable switches, and summarizing their advantages over Softwaredefined Networking (SDN) and legacy devices. The paper then presents a unique, comprehensive taxonomy of applications developed with P4 language; surveying, classifying, and analyzing more than 200 articles; discussing challenges and considerations; and presenting future perspectives and open research issues.},
	language = {en},
	urldate = {2023-01-24},
	journal = {IEEE Access},
	author = {Kfoury, Elie F. and Crichigno, Jorge and Bou-Harb, Elias},
	year = {2021},
	keywords = {Lu, P4 language, Protocols, data plane, Control systems, custom packet processing, Market research, Programmable switches, Security, Software, Software-defined Networking, taxonomy, Taxonomy, Technological innovation},
	pages = {87094--87155},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\LTMSR9U7\\9447791.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\9WUKD6M5\\Kfoury et al. - 2021 - An Exhaustive Survey on P4 Programmable Data Plane.pdf:application/pdf;Kfoury et al. - 2021 - An Exhaustive Survey on P4 Programmable Data Plane.pdf:C\:\\Users\\Yann\\Zotero\\storage\\ID7RDCZC\\Kfoury et al. - 2021 - An Exhaustive Survey on P4 Programmable Data Plane.pdf:application/pdf},
}

@article{hauser_survey_2023,
	title = {A {Survey} on {Data} {Plane} {Programming} with {P4}: {Fundamentals}, {Advances}, and {Applied} {Research}},
	volume = {212},
	issn = {10848045},
	shorttitle = {A {Survey} on {Data} {Plane} {Programming} with {P4}},
	url = {http://arxiv.org/abs/2101.10632},
	doi = {10.1016/j.jnca.2022.103561},
	abstract = {Programmable data planes allow users to deﬁne their own data plane algorithms for network devices including appropriate data plane application programming interfaces (APIs) which may be leveraged by user-deﬁned software-deﬁned networking (SDN) control. This oﬀers great ﬂexibility for network customization, be it for specialized, commercial appliances, e.g., in 5G or data center networks, or for rapid prototyping in industrial and academic research. Programming protocol-independent packet processors (P4) has emerged as the currently most widespread abstraction, programming language, and concept for data plane programming. It is developed and standardized by an open community, and it is supported by various software and hardware platforms.},
	language = {en},
	urldate = {2023-01-24},
	journal = {Journal of Network and Computer Applications},
	author = {Hauser, Frederik and Häberle, Marco and Merling, Daniel and Lindner, Steffen and Gurevich, Vladimir and Zeiger, Florian and Frank, Reinhard and Menth, Michael},
	month = mar,
	year = {2023},
	note = {arXiv:2101.10632 [cs]},
	keywords = {Computer Science - Networking and Internet Architecture},
	pages = {103561},
	file = {Hauser et al. - 2023 - A Survey on Data Plane Programming with P4 Fundam.pdf:C\:\\Users\\Yann\\Zotero\\storage\\KBUKAAAA\\Hauser et al. - 2023 - A Survey on Data Plane Programming with P4 Fundam.pdf:application/pdf},
}

@misc{the_p4org_applications_working_group_-band_2020,
	title = {In-band {Network} {Telemetry} ({INT}) {Dataplane} {Specification} v2.0},
	shorttitle = {{INT} {Dataplane} {Specification}},
	url = {https://p4.org/p4-spec/docs/telemetry_report_v1_0.pdf},
	urldate = {2023-01-23},
	author = {The P4.org Applications Working Group.},
	month = feb,
	year = {2020},
	file = {INT_v2_0.pdf:C\:\\Users\\Yann\\Zotero\\storage\\BL7A6KNY\\INT_v2_0.pdf:application/pdf},
}

@misc{noauthor_p4runtime_nodate,
	title = {{P4Runtime} {Specification}},
	url = {https://p4.org/p4-spec/p4runtime/v1.2.0/P4Runtime-Spec.html},
	urldate = {2023-01-24},
	file = {P4Runtime Specification:C\:\\Users\\Yann\\Zotero\\storage\\2AX2LWFI\\P4Runtime-Spec.html:text/html;P4Runtime Specification.pdf:C\:\\Users\\Yann\\Zotero\\storage\\7XVVKFF8\\P4Runtime Specification.pdf:application/pdf},
}

@misc{noauthor_p416_nodate,
	title = {P4{\textasciitilde}16{\textasciitilde} {Language} {Specification}},
	url = {https://p4.org/p4-spec/docs/P4-16-v1.2.2.html},
	urldate = {2023-01-24},
	file = {P4~16~ Language Specification:C\:\\Users\\Yann\\Zotero\\storage\\CCLCJUMS\\P4-16-v1.2.2.html:text/html;P4~16~ Language Specification.pdf:C\:\\Users\\Yann\\Zotero\\storage\\SQHJWGXM\\P4~16~ Language Specification.pdf:application/pdf},
}

@misc{noauthor_baidu_nodate,
	title = {Baidu {Intelligent} {Cloud} - {Intel}® {Tofino}™ {Expandable} {Architecture}},
	url = {https://www.intel.com/content/www/us/en/products/docs/programmable/baidu-tofino-xa-white-paper.html},
	abstract = {Baidu Intelligent Cloud is using Intel® Tofino™ Expandable Architecture in its cloud gateways to help meet terabit-level network traffic flows.},
	language = {en},
	urldate = {2023-01-23},
	journal = {Intel},
	keywords = {Lire},
	file = {Baidu Intelligent Cloud - Intel® Tofino™ Expandabl.pdf:C\:\\Users\\Yann\\Zotero\\storage\\NEUU4HY9\\Baidu Intelligent Cloud - Intel® Tofino™ Expandabl.pdf:application/pdf;Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\3E8Y9TFR\\baidu-tofino-xa-white-paper.html:text/html},
}

@inproceedings{luinaud_design_2021,
	address = {New York, NY, USA},
	series = {{FPGA} '21},
	title = {Design {Principles} for {Packet} {Deparsers} on {FPGAs}},
	isbn = {978-1-4503-8218-2},
	url = {https://doi.org/10.1145/3431920.3439303},
	doi = {10.1145/3431920.3439303},
	abstract = {The P4 language has drastically changed the networking field as it allows to quickly describe and implement new networking applications. Although a large variety of applications can be described with the P4 language, current programmable switch architectures impose significant constraints on P4 programs. To address this shortcoming, FPGAs have been explored as potential targets for P4 applications. P4 applications are described using three abstractions: a packet parser, match-action tables, and a packet deparser, which reassembles the output packet with the result of the match-action tables. While implementations of packet parsers and match-action tables on FPGAs have been widely covered in the literature, no general design principles have been presented for the packet deparser. Indeed, implementing a high-speed and efficient deparser on FPGAs remains an open issue because it requires a large amount of interconnections and the architecture must be tailored to a P4 program. As a result, in several works where a P4 application is implemented on FPGAs, the deparser consumes a significant proportion of chip resources. Hence, in this paper, we address this issue by presenting design principles for efficient and high-speed deparsers on FPGAs. As an artifact, we introduce a tool that generates an efficient vendor-agnostic deparser architecture from a P4 program.Our design has been validated and simulated with a cocotb-based framework.The resulting architecture is implemented on Xilinx Ultrascale+ FPGAs and supports a throughput of more than 200 Gbps while reducing resource usage by almost 10x compared to other solutions.},
	urldate = {2023-01-31},
	booktitle = {The 2021 {ACM}/{SIGDA} {International} {Symposium} on {Field}-{Programmable} {Gate} {Arrays}},
	publisher = {Association for Computing Machinery},
	author = {Luinaud, Thomas and Santiago da Silva, Jeferson and Langlois, J.M. Pierre and Savaria, Yvon},
	month = feb,
	year = {2021},
	keywords = {graph optimization, p4 language, packet deparsers, L1},
	pages = {280--286},
	annote = {Sujet: Comment optimiser l’étage d’egress sur FPGA, le talon d’Achilles des outils de synthèse existants: SDNet, P4FPGA, Compilateur Xilinx.
},
	file = {Version acceptée:C\:\\Users\\Yann\\Zotero\\storage\\ULR6WKYK\\Luinaud et al. - 2021 - Design Principles for Packet Deparsers on FPGAs.pdf:application/pdf},
}

@inproceedings{luinaud_bridging_2020,
	title = {Bridging the {Gap}: {FPGAs} as {Programmable} {Switches}},
	shorttitle = {Bridging the {Gap}},
	doi = {10.1109/HPSR48589.2020.9098978},
	abstract = {The emergence of P4, a domain specific language, coupled to PISA, a domain specific architecture, is revolutionizing the networking field. P4 allows to describe how packets are processed by a programmable data plane, spanning ASICs and CPUs, implementing PISA. Because the processing flexibility can be limited on ASICs, while the CPUs performance for networking tasks lag behind, recent works have proposed to implement PISA on FPGAs. However, little effort has been dedicated to analyze whether FPGAs are good candidates to implement PISA. In this work, we take a step back and evaluate the micro-architecture efficiency of various PISA blocks. We demonstrate, supported by a theoretical and experimental analysis, that the performance of a few PISA blocks is severely limited by the current FPGA architectures. Specifically, we show that match tables and programmable packet schedulers represent the main performance bottlenecks for FPGA-based programmable switches. Thus, we explore two avenues to alleviate these shortcomings. First, we identify network applications well tailored to current FPGAs. Second, to support a wider range of networking applications, we propose modifications to the FPGA architectures which can also be of interest out of the networking field.},
	booktitle = {2020 {IEEE} 21st {International} {Conference} on {High} {Performance} {Switching} and {Routing} ({HPSR})},
	author = {Luinaud, Thomas and Stimpfling, Thibaut and da Silva, Jeferson Santiago and Savaria, Yvon and Langlois, J.M. Pierre},
	month = may,
	year = {2020},
	note = {ISSN: 2325-5609},
	keywords = {Computer architecture, Fabrics, Field programmable gate arrays, FPGA, in-network computing, P4 language, Pipelines, PISA, Protocols, Random access memory, Scheduling algorithms},
	pages = {1--7},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\2EVVVSSC\\9098978.html:text/html;Version soumise:C\:\\Users\\Yann\\Zotero\\storage\\ECK9WX8G\\Luinaud et al. - 2020 - Bridging the Gap FPGAs as Programmable Switches.pdf:application/pdf},
}

@inproceedings{santiago_da_silva_p4-compatible_2018,
	address = {New York, NY, USA},
	series = {{FPGA} '18},
	title = {P4-{Compatible} {High}-{Level} {Synthesis} of {Low} {Latency} 100 {Gb}/s {Streaming} {Packet} {Parsers} in {FPGAs}},
	isbn = {978-1-4503-5614-5},
	url = {https://doi.org/10.1145/3174243.3174270},
	doi = {10.1145/3174243.3174270},
	abstract = {Packet parsing is a key step in SDN-aware devices. Packet parsers in SDN networks need to be both reconfigurable and fast, to support the evolving network protocols and the increasing multi-gigabit data rates. The combination of packet processing languages with FPGAs seems to be the perfect match for these requirements. In this work, we develop an open-source FPGA-based configurable architecture for arbitrary packet parsing to be used in SDN networks. We generate low latency and high-speed streaming packet parsers directly from a packet processing program. Our architecture is pipelined and entirely modeled using templated {\textbackslash}textttC++ classes. The pipeline layout is derived from a parser graph that corresponds to a P4 code after a series of graph transformation rounds. The RTL code is generated from the {\textbackslash}textttC++ description using Xilinx Vivado HLS and synthesized with Xilinx Vivado. Our architecture achieves a {\textbackslash}SI100 {\textbackslash}giga{\textbackslash}bit/{\textbackslash}second data rate in a Xilinx Virtex-7 FPGA while reducing the latency by 45\% and the LUT usage by 40\% compared to the state-of-the-art.},
	urldate = {2023-01-31},
	booktitle = {Proceedings of the 2018 {ACM}/{SIGDA} {International} {Symposium} on {Field}-{Programmable} {Gate} {Arrays}},
	publisher = {Association for Computing Machinery},
	author = {Santiago da Silva, Jeferson and Boyer, François-Raymond and Langlois, J.M. Pierre},
	month = feb,
	year = {2018},
	keywords = {Lu, p4, fpga, hls, packet parsers, programmable networks},
	pages = {147--152},
	file = {Version soumise:C\:\\Users\\Yann\\Zotero\\storage\\62329LAB\\Santiago da Silva et al. - 2018 - P4-Compatible High-Level Synthesis of Low Latency .pdf:application/pdf},
}

@misc{noauthor_composing_nodate,
	title = {Composing {Dataplane} {Programs} with μ{P4} {\textbar} {Proceedings} of the {Annual} conference of the {ACM} {Special} {Interest} {Group} on {Data} {Communication} on the applications, technologies, architectures, and protocols for computer communication},
	url = {https://dl.acm.org/doi/abs/10.1145/3387514.3405872},
	urldate = {2023-01-31},
	file = {Composing Dataplane Programs with μP4  Proceeding.pdf:C\:\\Users\\Yann\\Zotero\\storage\\K4RHTEQK\\Composing Dataplane Programs with μP4  Proceeding.pdf:application/pdf;Composing Dataplane Programs with μP4 | Proceedings of the Annual conference of the ACM Special Interest Group on Data Communication on the applications, technologies, architectures, and protocols for computer communication:C\:\\Users\\Yann\\Zotero\\storage\\U32IT56N\\3387514.html:text/html},
}

@inproceedings{fattaholmanan_p4_2021,
	address = {New York, NY, USA},
	series = {{SOSR} '21},
	title = {P4 {Weaver}: {Supporting} {Modular} and {Incremental} {Programming} in {P4}},
	isbn = {978-1-4503-9084-2},
	shorttitle = {P4 {Weaver}},
	url = {https://doi.org/10.1145/3482898.3483353},
	doi = {10.1145/3482898.3483353},
	abstract = {In this paper, we introduce P4 Weaver as an approach towards bringing modularity into the P4 language. P4 Weaver is designed to merge new data plane features into a base program in a principled and controlled way, so as to preserve the reliability of the switch. We also present an architecture for an integrated development environment that supports modular P4 programming while also safeguarding the intellectual property of the vendor code. We demonstrate the utility of P4 Weaver by adding three popular but non-trivial protocols to a P4 switch. We show that modularity is indeed beneficial and that P4 Weaver supports modularity efficiently and reliably.},
	urldate = {2023-01-31},
	booktitle = {Proceedings of the {ACM} {SIGCOMM} {Symposium} on {SDN} {Research} ({SOSR})},
	publisher = {Association for Computing Machinery},
	author = {Fattaholmanan, Ali and Baldi, Mario and Carzaniga, Antonio and Soulé, Robert},
	month = nov,
	year = {2021},
	keywords = {modular data-plane programming, source-to-source P4 compiler},
	pages = {54--65},
	file = {Fattaholmanan et al. - 2021 - P4 Weaver Supporting Modular and Incremental Prog.pdf:C\:\\Users\\Yann\\Zotero\\storage\\KR24RFSG\\Fattaholmanan et al. - 2021 - P4 Weaver Supporting Modular and Incremental Prog.pdf:application/pdf},
}

@misc{chowdhury_portland_2009,
	title = {{PortLand}: {A} {Scalable} {Fault}-{Tolerant} {Layer} 2 {Data} {Center} {Network} {Fabric} {\textbar} {Mosharaf} {Chowdhury}},
	shorttitle = {{PortLand}},
	url = {https://www.mosharaf.com/blog/2009/09/22/portland-a-scalable-fault-tolerant-layer-2-data-center-network-fabric/},
	language = {en-US},
	urldate = {2023-02-01},
	author = {Chowdhury, Mosharaf},
	month = sep,
	year = {2009},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\C7H2NF4V\\portland-a-scalable-fault-tolerant-layer-2-data-center-network-fabric.html:text/html},
}

@misc{lucas_understanding_2016,
	title = {Understanding {PortLand} - {Richard} {Lucas}' {Blog}},
	url = {http://blog.richardalucas.com/2016/04/28/Understanding-PortLand/},
	urldate = {2023-02-01},
	author = {Lucas, Richard},
	year = {2016},
	keywords = {Lu},
	file = {Understanding PortLand - Richard Lucas' Blog:C\:\\Users\\Yann\\Zotero\\storage\\UATEHNCY\\Understanding-PortLand.html:text/html},
}

@misc{noauthor_vlan_2023,
	title = {{VLAN}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=VLAN&oldid=1134281103},
	abstract = {A virtual local area network (VLAN) is any broadcast domain that is partitioned and isolated in a computer network at the data link layer (OSI layer 2). In this context, virtual, refers to a physical object recreated and altered by additional logic, within the local area network. VLANs work by applying tags to network frames and handling these tags in networking systems – creating the appearance and functionality of network traffic that is physically on a single network but acts as if it is split between separate networks. In this way, VLANs can keep network applications separate despite being connected to the same physical network, and without requiring multiple sets of cabling and networking devices to be deployed.
VLANs allow network administrators to group hosts together even if the hosts are not directly connected to the same network switch. Because VLAN membership can be configured through software, this can greatly simplify network design and deployment. Without VLANs, grouping hosts according to their resource needs the labor of relocating nodes or rewiring data links. VLANs allow devices that must be kept separate to share the cabling of a physical network and yet be prevented from directly interacting with one another. This managed sharing yields gains in simplicity, security, traffic management, and economy. For example, a VLAN can be used to separate traffic within a business based on individual users or groups of users or their roles (e.g. network administrators), or based on traffic characteristics (e.g. low-priority traffic prevented from impinging on the rest of the network's functioning). Many Internet hosting services use VLANs to separate customers' private zones from one other, allowing each customer's servers to be grouped in a single network segment no matter where the individual servers are located in the data center. Some precautions are needed to prevent traffic "escaping" from a given VLAN, an exploit known as VLAN hopping.
To subdivide a network into VLANs, one configures network equipment. Simpler equipment might partition only each physical port (if even that), in which case each VLAN runs over a dedicated network cable. More sophisticated devices can mark frames through VLAN tagging, so that a single interconnect (trunk) may be used to transport data for multiple VLANs. Since VLANs share bandwidth, a VLAN trunk can use link aggregation, quality-of-service prioritization, or both to route data efficiently.},
	language = {en},
	urldate = {2023-02-02},
	journal = {Wikipedia},
	month = jan,
	year = {2023},
	note = {Page Version ID: 1134281103},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\AWUKND4W\\VLAN.html:text/html},
}

@misc{noauthor_ieee_2022,
	title = {{IEEE} 802.{1Q}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=IEEE_802.1Q&oldid=1128288082},
	abstract = {IEEE 802.1Q, often referred to as Dot1q, is the networking standard that supports virtual local area networking (VLANs) on an IEEE 802.3 Ethernet network. The standard defines a system of VLAN tagging for Ethernet frames and the accompanying procedures to be used by bridges and switches in handling such frames. The standard also contains provisions for a quality-of-service prioritization scheme commonly known as IEEE 802.1p and defines the Generic Attribute Registration Protocol.
Portions of the network which are VLAN-aware (i.e., IEEE 802.1Q conformant) can include VLAN tags.  When a frame enters the VLAN-aware portion of the network, a tag is added to represent the VLAN membership.  Each frame must be distinguishable as being within exactly one VLAN.  A frame in the VLAN-aware portion of the network that does not contain a VLAN tag is assumed to be flowing on the native VLAN.
The standard was developed by IEEE 802.1, a working group of the IEEE 802 standards committee, and continues to be actively revised. One of the notable revisions is 802.1Q-2014 which incorporated IEEE 802.1aq (Shortest Path Bridging) and much of the IEEE 802.1D standard.},
	language = {en},
	urldate = {2023-02-02},
	journal = {Wikipedia},
	month = dec,
	year = {2022},
	note = {Page Version ID: 1128288082},
	keywords = {Survolé},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\QJQXNPUS\\IEEE_802.html:text/html},
}

@misc{noauthor_ethertype_2022,
	title = {{EtherType}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://fr.wikipedia.org/w/index.php?title=EtherType&oldid=192325643},
	abstract = {EtherType est un champ d'une trame Ethernet indiquant quel est le protocole de niveau supérieur utilisé dans le champ "donnée" de cette trame.},
	language = {fr},
	urldate = {2023-02-02},
	journal = {Wikipédia},
	month = mar,
	year = {2022},
	note = {Page Version ID: 192325643},
	keywords = {Survolé},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\7E4GJ9I6\\EtherType.html:text/html},
}

@misc{noauthor_tcam_nodate,
	title = {{TCAM} demystified},
	url = {https://learningnetwork.cisco.com/s/article/tcam-demystified},
	urldate = {2023-02-03},
	file = {TCAM demystified:C\:\\Users\\Yann\\Zotero\\storage\\JIWX5LAU\\tcam-demystified.html:text/html},
}

@inproceedings{asai_palmtrie_2020,
	address = {New York, NY, USA},
	series = {{CoNEXT} '20},
	title = {Palmtrie: a ternary key matching algorithm for {IP} packet filtering rules},
	isbn = {978-1-4503-7948-9},
	shorttitle = {Palmtrie},
	url = {https://doi.org/10.1145/3386367.3431289},
	doi = {10.1145/3386367.3431289},
	abstract = {Network security has become crucial to our society and industry. A firewall is an essential function in network operations for security enhancement. Network access control lists (ACLs) have been used to describe multi-layer security rules to determine whether a packet is passed or dropped by the firewall. An entry in ACLs contains so-called don't care bits, and consequently, ACL matching is generalized as a ternary matching problem. As ternary matching typically relies on dedicated hardware, high-performance ternary matching with commodity CPUs is challenging. We propose a practical algorithm for network ACL matching trie, named Palmtrie, that allows the multi-bit stride extension to achieve better performance. We evaluate the Palmtrie using synthetic ACLs that emulate an existing campus network and Internet backbone policies. The evaluation results demonstrate that the Palmtrie outperforms the existing ACL matching algorithms on extensive ACLs. For example, the lookup performance of the optimized Palmtrie achieves 4.76 times faster than the algorithm implemented in the widely used library (DPDK) for the scanning attack traffic on an ACL with one million entries. We also prove that the Palmtrie solves the problem with the build time of data structures in the existing algorithms.},
	urldate = {2023-02-03},
	booktitle = {Proceedings of the 16th {International} {Conference} on emerging {Networking} {EXperiments} and {Technologies}},
	publisher = {Association for Computing Machinery},
	author = {Asai, Hirochika},
	month = nov,
	year = {2020},
	keywords = {access control list, firewalls, packet classification, ternary matching},
	pages = {323--335},
	file = {Asai - 2020 - Palmtrie a ternary key matching algorithm for IP .pdf:C\:\\Users\\Yann\\Zotero\\storage\\KBQNXC7G\\Asai - 2020 - Palmtrie a ternary key matching algorithm for IP .pdf:application/pdf},
}

@misc{noauthor_micronugget_nodate,
	title = {{MicroNugget}: {What} is {Multi}-{Protocol} {Label} {Switching} ({MPLS})? - {YouTube}},
	url = {https://www.youtube.com/watch?v=huKkCK8AJ7I},
	urldate = {2023-02-03},
	keywords = {Lu},
	file = {MicroNugget\: What is Multi-Protocol Label Switching (MPLS)? - YouTube:C\:\\Users\\Yann\\Zotero\\storage\\J73Y4HG8\\watch.html:text/html},
}

@inproceedings{mashreghi-moghadam_templated_2022,
	title = {A {Templated} {VHDL} {Architecture} for {Terabit}/s {P4}-programmable {FPGA}-based {Packet} {Parsing}},
	doi = {10.1109/ISCAS48785.2022.9937607},
	abstract = {This paper proposes a templated VHDL architecture for P4-programmable packet parsing on FPGAs offering high throughput while occupying a small area footprint. The architecture comprises a multi-stage header parser unit arranged in a pipelined structure. Each header analysis unit is characterized by a set of generic parameters reflecting unique features and relations of supported protocols retrieved from the P4 code that describes each stage along the pipeline. Synthesis results of the packet parser show up to 549 Gb/s throughput on a Xilinx Virtex-7 FPGA and 1 Tb/s on a Xilinx UltraScale+ for a twelve-stage pipeline. Compared with state-of-the-art solutions, our proposed architecture performs at higher throughput with acceptable resource utilization.},
	booktitle = {2022 {IEEE} {International} {Symposium} on {Circuits} and {Systems} ({ISCAS})},
	author = {Mashreghi-Moghadam, Parisa and Ould-Bachir, Tarek and Savaria, Yvon},
	month = may,
	year = {2022},
	note = {ISSN: 2158-1525},
	keywords = {FPGA, P4 language, Pipelines, Protocols, Circuits and systems, Codes, Microarchitecture, packet parser, Throughput, VHDL},
	pages = {672--676},
	file = {IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\WRUHJ4AY\\Mashreghi-Moghadam et al. - 2022 - A Templated VHDL Architecture for Terabits P4-pro.pdf:application/pdf},
}

@misc{noauthor_content-addressable_2022,
	title = {Content-addressable memory},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Content-addressable_memory&oldid=1120173075#Ternary_CAMs},
	abstract = {Content-addressable memory (CAM) is a special type of computer memory used in certain very-high-speed searching applications. It is also known as associative memory or associative storage and compares input search data against a table of stored data, and returns the address of matching data.CAM is frequently used in networking devices where it speeds up forwarding information base and routing table operations. This kind of associative memory is also used in cache memory. In associative cache memory, both address and content is stored side by side. When the address matches, the corresponding content is fetched from cache memory.},
	language = {en},
	urldate = {2023-02-03},
	journal = {Wikipedia},
	month = nov,
	year = {2022},
	note = {Page Version ID: 1120173075},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\UUCCYJF5\\Content-addressable_memory.html:text/html},
}

@misc{noauthor_static_2023,
	title = {Static random-access memory},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Static_random-access_memory&oldid=1136936708},
	abstract = {Static random-access memory (static RAM or SRAM)  is a type of random-access memory (RAM) that uses latching circuitry (flip-flop) to store each bit. SRAM is volatile memory; data is lost when power is removed.
The term static differentiates SRAM from DRAM (dynamic random-access memory) — SRAM will hold its data permanently in the presence of power, while data in DRAM decays in seconds and thus must be periodically refreshed.  SRAM is faster than DRAM but it is more expensive in terms of silicon area and cost; it is typically used for the cache and internal registers of a CPU while DRAM is used for a computer's main memory.},
	language = {en},
	urldate = {2023-02-03},
	journal = {Wikipedia},
	month = feb,
	year = {2023},
	note = {Page Version ID: 1136936708},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\9ZQTLMUH\\Static_random-access_memory.html:text/html},
}

@article{pagiamtzis_content-addressable_2006,
	title = {Content-{Addressable} {Memory} ({CAM}) {Circuits} and {Architectures}: {A} {Tutorial} and {Survey}},
	volume = {41},
	issn = {0018-9200},
	shorttitle = {Content-{Addressable} {Memory} ({CAM}) {Circuits} and {Architectures}},
	url = {http://ieeexplore.ieee.org/document/1599540/},
	doi = {10.1109/JSSC.2005.864128},
	abstract = {We survey recent developments in the design of large-capacity content-addressable memory (CAM). A CAM is a memory that implements the lookup-table function in a single clock cycle using dedicated comparison circuitry. CAMs are especially popular in network routers for packet forwarding and packet classiﬁcation, but they are also beneﬁcial in a variety of other applications that require high-speed table lookup. The main CAM-design challenge is to reduce power consumption associated with the large amount of parallel active circuitry, without sacriﬁcing speed or memory density. In this paper, we review CAM-design techniques at the circuit level and at the architectural level. At the circuit level, we review low-power matchline sensing techniques and searchline driving approaches. At the architectural level we review three methods for reducing power consumption.},
	language = {en},
	number = {3},
	urldate = {2023-02-03},
	journal = {IEEE Journal of Solid-State Circuits},
	author = {Pagiamtzis, K. and Sheikholeslami, A.},
	month = mar,
	year = {2006},
	keywords = {Application software, Bank selection, CADCAM, Circuits, Clocks, Computer aided manufacturing, content-addressable memory (CAM), Energy consumption, Image coding, IP networks, matchline pipelining, matchline sensing, NAND cell, NOR cell, review, searchline power, Table lookup, Tutorial},
	pages = {712--727},
	file = {Pagiamtzis et Sheikholeslami - 2006 - Content-Addressable Memory (CAM) Circuits and Arch.pdf:C\:\\Users\\Yann\\Zotero\\storage\\TAS5523Y\\Pagiamtzis et Sheikholeslami - 2006 - Content-Addressable Memory (CAM) Circuits and Arch.pdf:application/pdf},
}

@article{chisvin_content-addressable_1989,
	title = {Content-addressable and associative memory: alternatives to the ubiquitous {RAM}},
	volume = {22},
	issn = {0018-9162},
	shorttitle = {Content-addressable and associative memory},
	url = {http://ieeexplore.ieee.org/document/30732/},
	doi = {10.1109/2.30732},
	number = {7},
	urldate = {2023-02-03},
	journal = {Computer},
	author = {Chisvin, L. and Duckworth, R.J.},
	month = jul,
	year = {1989},
	pages = {51--64},
}

@article{pei_putting_1992,
	title = {Putting routing tables in silicon},
	volume = {6},
	issn = {0890-8044},
	url = {http://ieeexplore.ieee.org/document/120723/},
	doi = {10.1109/65.120723},
	number = {1},
	urldate = {2023-02-03},
	journal = {IEEE Network},
	author = {Pei, T.-B. and Zukowski, C.},
	month = jan,
	year = {1992},
	pages = {42--50},
	file = {Pei et Zukowski - 1992 - Putting routing tables in silicon.pdf:C\:\\Users\\Yann\\Zotero\\storage\\N3LEVBUE\\Pei et Zukowski - 1992 - Putting routing tables in silicon.pdf:application/pdf},
}

@inproceedings{stas_associative_1993,
	address = {Portland, OR, USA},
	title = {Associative processing with {CAMs}},
	isbn = {978-0-7803-9972-3},
	url = {http://ieeexplore.ieee.org/document/505050/},
	doi = {10.1109/NORTHC.1993.505050},
	urldate = {2023-02-03},
	booktitle = {Proceedings of {NORTHCON}'93 {Electrical} and {Electronics} {Convention}},
	publisher = {IEEE},
	author = {Stas, S.},
	year = {1993},
	pages = {161--167},
}

@book{oleary_essential_2004,
	address = {London ; Thoundand Oaks},
	title = {The essential guide to doing research},
	isbn = {978-0-7619-4198-9 978-0-7619-4199-6},
	language = {en},
	publisher = {SAGE},
	author = {O'Leary, Zina},
	year = {2004},
	note = {OCLC: ocm55736969},
	keywords = {Methodology, Research},
	file = {O'Leary - 2004 - The essential guide to doing research.pdf:C\:\\Users\\Yann\\Zotero\\storage\\8XKCSRYE\\O'Leary - 2004 - The essential guide to doing research.pdf:application/pdf},
}

@article{cao_p4_2020,
	title = {P4 to {FPGA}-{A} {Fast} {Approach} for {Generating} {Efficient} {Network} {Processors}},
	volume = {8},
	issn = {2169-3536},
	doi = {10.1109/ACCESS.2020.2970683},
	abstract = {This paper presents a framework for converting P4 programs to VHDL and then implementing them on Field-Programmable Gate Array (FPGA) platforms. In this framework, a match-action-based hardware architecture is introduced with clearly designed components, which correspond to the described functionalities in the P4 programs. A pre-built template library is used for the compilation that includes optimized VHDL templates corresponding to specific clearly designed components. From the output of a standard frontend P4 compiler, the proposed compiler extracts parameters and relationships within the functions being employed, maps them to corresponding templates by calling, configuring, optimizing and instantiating them, and finally generates the appropriate FPGA code. A pre-built evaluation library is also proposed that helps the compiler to optimize the implementation during the mapping phase. A prototype of this framework is also implemented and evaluated; in this process, it is found that the generated processors use few resources and have high throughput and low latency. Compared with a state-of-the-art solution, the packet processing time is halved. In addition, the generated processors are able to operate at a line rate of nearly 100 Gigabits per second for a basic layer-3 forwarding application.},
	journal = {IEEE Access},
	author = {Cao, Zhuang and Su, Huayou and Yang, Qianming and Shen, Junzhong and Wen, Mei and Zhang, Chunyuan},
	year = {2020},
	note = {Conference Name: IEEE Access},
	keywords = {Computer architecture, Field programmable gate arrays, FPGA, VHDL, Clocks, Hardware, network processor, P4, Program processors, template},
	pages = {23440--23456},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\BES7JRJ4\\8976091.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\2UUBR4AN\\Cao et al. - 2020 - P4 to FPGA-A Fast Approach for Generating Efficien.pdf:application/pdf},
}

@inproceedings{yang_elastic_2018,
	address = {New York},
	title = {Elastic {Sketch}: {Adaptive} and {Fast} {Network}-wide {Measurements}},
	isbn = {978-1-4503-5567-4},
	shorttitle = {Elastic {Sketch}},
	url = {https://dl.acm.org/doi/10.1145/3230543.3230544},
	doi = {10.1145/3230543.3230544},
	abstract = {When network is undergoing problems such as congestion, scan attack, DDoS attack, etc., measurements are much more important than usual. In this case, traffic characteristics including available bandwidth, packet rate, and flow size distribution vary drastically, significantly degrading the performance of measurements. To address this issue, we propose the Elastic sketch. It is adaptive to currently traffic characteristics. Besides, it is generic to measurement tasks and platforms. We implement the Elastic sketch on six platforms: P4, FPGA, GPU, CPU, multi-core CPU, and OVS, to process six typical measurement tasks. Experimental results and theoretical analysis show that the Elastic sketch can adapt well to traffic characteristics. Compared to the state-of-the-art, the Elastic sketch achieves 44.6 similar to 45.2 times faster speed and 2.0 similar to 273.7 smaller error rate.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Proceedings of the 2018 {Conference} of the {Acm} {Special} {Interest} {Group} on {Data} {Communication} (sigcomm '18)},
	publisher = {Assoc Computing Machinery},
	author = {Yang, Tong and Jiang, Jie and Liu, Peng and Huang, Qun and Gong, Junzhi and Zhou, Yang and Miao, Rui and Li, Xiaoming and Uhlig, Steve},
	year = {2018},
	note = {WOS:000482127900039},
	keywords = {Compression, Elastic, Generic, Network measurements, Sketches},
	pages = {561--575},
}

@inproceedings{miao_silkroad_2017,
	address = {New York},
	title = {{SilkRoad}: {Making} {Stateful} {Layer}-4 {Load} {Balancing} {Fast} and {Cheap} {Using} {Switching} {ASICs}},
	isbn = {978-1-4503-4653-5},
	shorttitle = {{SilkRoad}},
	url = {https://dl.acm.org/doi/10.1145/3098822.3098824},
	doi = {10.1145/3098822.3098824},
	abstract = {In this paper, we show that up to hundreds of software load balancer (SLB) servers can be replaced by a single modern switching ASIC, potentially reducing the cost of load balancing by over two orders of magnitude. Today, large data centers typically employ hundreds or thousands of servers to load-balance incoming traffic over application servers. These software load balancers (SLBs) map packets destined to a service (with a virtual IP address, or VIP), to a pool of servers tasked with providing the service (with multiple direct IP addresses, or DIPs). An SLB is stateful, it must always map a connection to the same server, even if the pool of servers changes and/or if the load is spread differently across the pool. This property is called per-connection consistency or PCC. The challenge is that the load balancer must keep track of millions of connections simultaneously. Until recently, it was not possible to implement a load balancer with PCC in a merchant switching ASIC, because high-performance switching ASICs typically can not maintain per-connection states with PCC. Newer switching ASICs provide resources and primitives to enable PCC at a large scale. In this paper, we explore how to use switching ASICs to build much faster load balancers than have been built before. Our system, called SilkRoad, is defined in a 400 line P4 program and when compiled to a state-of-the-art switching ASIC, we show it can load-balance ten million connections simultaneously at line rate.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Sigcomm '17: {Proceedings} of the 2017 {Conference} of the {Acm} {Special} {Interest} {Group} on {Data} {Communication}},
	publisher = {Assoc Computing Machinery},
	author = {Miao, Rui and Zeng, Hongyi and Kim, Changhoon and Lee, Jeongkeun and Yu, Minlan},
	year = {2017},
	note = {WOS:000414280000002},
	keywords = {Programmable switches, Load balancing},
	pages = {15--28},
}

@inproceedings{handley_re-architecting_2017,
	address = {New York},
	title = {Re-architecting datacenter networks and stacks for low latency and high performance},
	isbn = {978-1-4503-4653-5},
	url = {https://dl.acm.org/doi/10.1145/3098822.3098825},
	doi = {10.1145/3098822.3098825},
	abstract = {Modern datacenter networks provide very high capacity via redundant Clos topologies and low switch latency, but transport protocols rarely deliver matching performance. We present NDP, a novel data-center transport architecture that achieves near-optimal completion times for short transfers and high flow throughput in a wide range of scenarios, including incast. NDP switch buffers are very shallow and when they fill the switches trim packets to headers and priority forward the headers. This gives receivers a full view of instantaneous demand from all senders, and is the basis for our novel, high-performance, multipath-aware transport protocol that can deal gracefully with massive incast events and prioritize traffic from different senders on RTT timescales. We implemented NDP in Linux hosts with DPDK, in a software switch, in a NetFPGA-based hardware switch, and in P4. We evaluate NDP's performance in our implementations and in large-scale simulations, simultaneously demonstrating support for very low-latency and high throughput.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Sigcomm '17: {Proceedings} of the 2017 {Conference} of the {Acm} {Special} {Interest} {Group} on {Data} {Communication}},
	publisher = {Assoc Computing Machinery},
	author = {Handley, Mark and Raiciu, Costin and Agache, Alexandru and Voinescu, Andrei and Moore, Andrew W. and Antichi, Gianni and Wojcik, Marcin},
	year = {2017},
	note = {WOS:000414280000003},
	keywords = {Datacenters, Network Stacks, Transport Protocols},
	pages = {29--42},
	file = {Texte intégral:C\:\\Users\\Yann\\Zotero\\storage\\DRX7CB2K\\Handley et al. - 2017 - Re-architecting datacenter networks and stacks for.pdf:application/pdf},
}

@inproceedings{ibanez_p4_2019,
	address = {New York},
	title = {The {P4} -{\textgreater} {NetFPGA} {Workflow} for {Line}-{Rate} {Packet} {Processing}},
	isbn = {978-1-4503-6137-8},
	url = {https://dl.acm.org/doi/10.1145/3289602.3293924},
	doi = {10.1145/3289602.3293924},
	abstract = {P4 has emerged as the de facto standard language for describing how network packets should be processed, and is becoming widely used by network owners, systems developers, researchers and in the classroom. The goal of the work presented here is to make it easier for engineers, researchers and students to learn how to program using P4, and to build prototypes running on real hardware. Our target is the NetFPGA SUME platform, a 4 x 10 Gb/s PCIe card designed for use in universities for teaching and research. Until now, NetFPGA users have needed to learn an HDL such as Verilog or VHDL, making it off limits to many software developers and students. Therefore, we developed the P4 -{\textgreater} NetFPGA workflow, allowing developers to describe how packets are to be processed in the high-level P4 language, then compile their P4 programs to run at line rate on the NetFPGA SUME board. The P4 -{\textgreater} NetFPGA workflow is built upon the Xilinx P4-SDNet compiler and the NetFPGA SUME open source code base. In this paper, we provide an overview of the P4 programming language and describe the P4 -{\textgreater} NetFPGA workflow. We also describe how the workflow is being used by the P4 community to build research prototypes, and to teach how network systems are built by providing students with hands-on experience working with real hardware.},
	language = {English},
	urldate = {2023-02-08},
	booktitle = {Proceedings of the 2019 {Acm}/{Sigda} {International} {Symposium} on {Field}-{Programmable} {Gate} {Arrays} (fpga'19)},
	publisher = {Assoc Computing Machinery},
	author = {Ibanez, Stephen and Brebner, Gordon and McKeown, Nick and Zilberman, Noa},
	year = {2019},
	note = {WOS:000522383700001},
	pages = {1--9},
}

@book{ridley_literature_2012,
	title = {The {Literature} {Review}: {A} {Step}-by-{Step} {Guide} for {Students}},
	isbn = {978-1-4462-6804-9},
	shorttitle = {The {Literature} {Review}},
	abstract = {This second edition of Diana Ridley′s bestselling book provides a step-by-step guide to conducting a literature search and literature review, using cases and examples throughout to demonstrate best practice. Ridley outlines practical strategies for conducting a systematic search of the available literature, reading and note taking and writing up your literature review as part of an undergraduate research project, Masters dissertation or PhD thesis. New to this edition are:  Examples drawn from a wide range of disciplines  A new chapter on conducting systematic reviews  Increased guidance on evaluating the quality of online sources and online literature  Enhanced guidance in dealing with copyright and permissions issues.   This book also comes with a companion website containing a wide range of examples of successful literature reviews from various academic disciplines.  SAGE Study Skills are essential study guides for students of all levels. From how to write great essays and succeeding at university, to writing your undergraduate dissertation and doing postgraduate research, SAGE Study Skills help you get the best from your time at university. Visit the SAGE Study Skills hub for tips, quizzes and videos on study success!},
	language = {en},
	publisher = {SAGE},
	author = {Ridley, Diana},
	month = jul,
	year = {2012},
	keywords = {Reference / Research, Study Aids / General},
}

@incollection{hauck_introduction_2008,
	address = {Burlington},
	series = {Systems on {Silicon}},
	title = {Introduction},
	url = {https://www.sciencedirect.com/science/article/pii/B9780123705228500030},
	language = {en},
	urldate = {2023-02-10},
	booktitle = {Reconfigurable {Computing}},
	publisher = {Morgan Kaufmann},
	editor = {Hauck, Scott and Dehon, André},
	month = jan,
	year = {2008},
	doi = {10.1016/B978-012370522-8.50003-0},
	pages = {xxv--xxix},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\64Z5HXD2\\Hauck et Dehon - 2008 - Introduction.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\FJ3DZM4C\\reconfigurable-computing.html:text/html},
}

@incollection{chang_device_2008,
	title = {Device {Architecture}},
	isbn = {978-0-12-370522-8},
	url = {https://linkinghub.elsevier.com/retrieve/pii/B9780123705228500054},
	language = {en},
	urldate = {2023-02-10},
	booktitle = {Reconfigurable {Computing}: {The} {Theory} and {Practice} of {FPGA}-{Based} {Computation}},
	publisher = {Elsevier},
	author = {Chang, Mark L.},
	year = {2008},
	doi = {10.1016/B978-012370522-8.50005-4},
	keywords = {Lu},
	pages = {3--27},
	file = {Chang - 2008 - Device Architecture.pdf:C\:\\Users\\Yann\\Zotero\\storage\\E8955ABF\\Chang - 2008 - Device Architecture.pdf:application/pdf},
}

@misc{noauthor_multiprotocol_2023,
	title = {Multiprotocol {Label} {Switching}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Multiprotocol_Label_Switching&oldid=1137499050},
	abstract = {Multiprotocol Label Switching (MPLS) is a routing technique in telecommunications networks that directs data from one node to the next based on labels rather than network addresses. Whereas network addresses identify endpoints the labels identify established paths between endpoints. MPLS can encapsulate packets of various network protocols, hence the multiprotocol component of the name. MPLS supports a range of access technologies, including T1/E1, ATM, Frame Relay, and DSL.},
	language = {en},
	urldate = {2023-02-14},
	journal = {Wikipedia},
	month = feb,
	year = {2023},
	note = {Page Version ID: 1137499050},
	keywords = {Survolé},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\ZAY7IBBQ\\Multiprotocol_Label_Switching.html:text/html},
}

@book{noauthor_oracle_2004,
	title = {Oracle {VM} {VirtualBox} {User} {Manual}},
	url = {https://www.virtualbox.org/manual/},
	urldate = {2023-01-20},
	year = {2004},
	keywords = {Lu partiellement},
	file = {VirtualBox_user_manual.pdf:C\:\\Users\\Yann\\Zotero\\storage\\FSLBQKBC\\VirtualBox_user_manual.pdf:application/pdf},
}

@misc{noauthor_von_nodate,
	title = {Von {Neumann} architecture - {Wikipedia}},
	url = {https://en.wikipedia.org/wiki/Von_Neumann_architecture#Von_Neumann_bottleneck},
	urldate = {2023-02-17},
	keywords = {Lu partiellement},
	annote = {Section: Von Neumann bottleneck
},
	file = {Von Neumann architecture - Wikipedia:C\:\\Users\\Yann\\Zotero\\storage\\DS2DF9NF\\Von_Neumann_architecture.html:text/html},
}

@misc{noauthor_reconfigurable_2022,
	title = {Reconfigurable computing},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Reconfigurable_computing&oldid=1107624488},
	abstract = {Reconfigurable computing is a computer architecture combining some of the flexibility of software with the high performance of hardware by processing with very flexible high speed computing fabrics like field-programmable gate arrays (FPGAs). The principal difference when compared to using ordinary microprocessors is the ability to make substantial changes to the datapath itself in addition to the control flow. On the other hand, the main difference from custom hardware, i.e. application-specific integrated circuits (ASICs) is the possibility to adapt the hardware during runtime by "loading" a new circuit on the reconfigurable fabric.},
	language = {en},
	urldate = {2023-02-17},
	journal = {Wikipedia},
	month = aug,
	year = {2022},
	note = {Page Version ID: 1107624488},
	keywords = {Lu},
	annote = {Résumé: le moyen principal d’ajouter de la reconfigurabilité est d’avoir une architecture partiellement reconfigurable. Xilinx et Intel ont tous les deux certains modèles conçus pour être reconfigurables. Deux types de FPGAs partiellement reconfigurables:
Statique: on a pas besoin de réécrire tout le bitstream pour la reconfiguration, mais tout le FPGA doit être reset pendant le processus
Dynamique: plus intéressant, toute la partie non-reconfigurée du FPGA continue à fonctionner pendant qu’on reconfigure le reste.
La reconfigurabilité est permise par le design hiérarchique et modulaire: typiquement, on reconfigure une entité séparément du reste. Par exemple, un périphérique ou un coprocesseur connecté au CPU.
Avis: pas super, l’écriture part un peu dans tout les sens, passe trop de temps sur les différences entre FPGAs à granularité fine ou grossière. Pas de ligne directrice claire.
},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\9NEGQ7VW\\Reconfigurable_computing.html:text/html},
}

@misc{noauthor_translation_2023,
	title = {Translation lookaside buffer},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Translation_lookaside_buffer&oldid=1135682679},
	abstract = {A translation lookaside buffer (TLB) is a memory cache that stores the recent translations of virtual memory to physical memory. It is used to reduce the time taken to access a user memory location. It can be called an address-translation cache.  It is a part of the chip's memory-management unit (MMU). A TLB may reside between the CPU and the CPU cache, between CPU cache and the main memory or between the different levels of the multi-level cache. The majority of desktop, laptop, and server processors include one or more TLBs in the memory-management hardware, and it is nearly always present in any processor that utilizes paged or segmented virtual memory.
The TLB is sometimes implemented as content-addressable memory (CAM). The CAM search key is the virtual address, and the search result is a physical address. If the requested address is present in the TLB, the CAM search yields a match quickly and the retrieved physical address can be used to access memory. This is called a TLB hit. If the requested address is not in the TLB, it is a miss, and the translation proceeds by looking up the page table in a process called a page walk. The page walk is time-consuming when compared to the processor speed, as it involves reading the contents of multiple memory locations and using them to compute the physical address. After the physical address is determined by the page walk, the virtual address to physical address mapping is entered into the TLB.  The PowerPC 604, for example, has a two-way set-associative TLB for data loads and stores. Some processors have different instruction and data address TLBs.},
	language = {en},
	urldate = {2023-02-17},
	journal = {Wikipedia},
	month = jan,
	year = {2023},
	note = {Page Version ID: 1135682679},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\HWVGF6AF\\Translation_lookaside_buffer.html:text/html},
}

@misc{noauthor_page_2022,
	title = {Page table},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Page_table&oldid=1083393269},
	abstract = {A page table is the data structure used by a virtual memory system in a computer operating system to store the mapping between virtual addresses and physical addresses.  Virtual addresses are used by the program executed by the accessing process, while physical addresses are used by the hardware, or more specifically, by the random-access memory (RAM) subsystem. The page table is a key component of virtual address translation that is necessary to access data in memory.},
	language = {en},
	urldate = {2023-02-17},
	journal = {Wikipedia},
	month = apr,
	year = {2022},
	note = {Page Version ID: 1083393269},
	keywords = {Lu partiellement},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\4TFV8QCF\\Page_table.html:text/html},
}

@inproceedings{feng_-situ_2021,
	address = {New York, NY, USA},
	series = {{HotNets} '21},
	title = {In-situ {Programmable} {Switching} using {rP4}: {Towards} {Runtime} {Data} {Plane} {Programmability}},
	isbn = {978-1-4503-9087-3},
	shorttitle = {In-situ {Programmable} {Switching} using {rP4}},
	url = {https://doi.org/10.1145/3484266.3487367},
	doi = {10.1145/3484266.3487367},
	abstract = {The existing chip architecture and programming language are incapable of supporting in-service updates by loading or offloading on-demand protocols and functions at runtime. We examine the fundamental reasons for the inflexibility and design a new In-situ Programmable Switch Architecture (IPSA) as a fix. We further design rP4, a P4 extension, for programming IPSA-based devices. To manifest the in-situ programming feasibility, we develop an rP4 compiler and demonstrate several use cases on both a software switch, ipbm, and an FPGA-based prototype. Our preliminary experiments and analysis show that, compared to PISA, IPSA provides higher flexibility in enabling runtime functional update with limited performance and gate-count penalty. The in-situ programming capability enabled by IPSA and rP4 opens a promising design space for programmable networks.},
	urldate = {2023-02-20},
	booktitle = {Proceedings of the {Twentieth} {ACM} {Workshop} on {Hot} {Topics} in {Networks}},
	publisher = {Association for Computing Machinery},
	author = {Feng, Yong and Song, Haoyu and Li, Jiahao and Chen, Zhikang and Xu, Wenquan and Liu, Bin},
	month = nov,
	year = {2021},
	keywords = {L1},
	pages = {69--76},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\3M4998FH\\Feng et al. - 2021 - In-situ Programmable Switching using rP4 Towards .pdf:application/pdf},
}

@inproceedings{benacek_p4--vhdl_2016,
	title = {P4-to-{VHDL}: {Automatic} {Generation} of 100 {Gbps} {Packet} {Parsers}},
	shorttitle = {P4-to-{VHDL}},
	doi = {10.1109/FCCM.2016.46},
	abstract = {Software Defined Networking and OpenFlow offer an elegant way to decouple network control plane from data plane. This decoupling has led to great innovation in the control plane, yet the data plane changes come at much slower pace, mainly due to the hard-wired implementation of network switches. The P4 language aims to overcome this obstacle by providing a description of a customized packet processing functionality for configurable switches. That enables a new generation of possibly heterogeneous networking hardware that can be runtime tailored for the needs of particular applications from various domains. In this paper we contribute to the idea of P4 by presenting design, analysis and experimental results of our packet parser generator. The generator converts a parse graph description of P4 to a synthetizable VHDL code suitable for FPGA implementation. Our results show that the generated circuit is able to parse 100 Gbps traffic with fairly complex protocol structure at line rate on a Xilinx Virtex-7 FPGA. The approach can be used not only in switches, but also in other appliances, such as application accelerators and smart NICs. We compare the generated output to a hand-written parser to show that the price for configurability is only a slightly larger and slower circuit.},
	booktitle = {2016 {IEEE} 24th {Annual} {International} {Symposium} on {Field}-{Programmable} {Custom} {Computing} {Machines} ({FCCM})},
	author = {Benácek, Pavel and Pu, Viktor and Kubátová, Hana},
	month = may,
	year = {2016},
	keywords = {Computer architecture, Field programmable gate arrays, Pipelines, Protocols, Program processors, Data mining, Generators},
	pages = {148--155},
	annote = {Avis: génération VHDL, puis synthèse sous Vivado.
Le papier ne dit pas si les ‘tests’ mentionnés ont été faits en simulation ou avec des vrais paquets.
},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\NGASQLCB\\7544769.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\4SHYU5S9\\Benácek et al. - 2016 - P4-to-VHDL Automatic Generation of 100 Gbps Packe.pdf:application/pdf},
}

@misc{noauthor_intel_nodate,
	title = {Intel {Learning}},
	url = {https://learning.intel.com/developer/learn/course/external/view/elearning/378/partial-reconfiguration-for-intel-fpga-devices-pr-host-ip-implementations},
	urldate = {2023-02-21},
}

@article{kastovsky_building_nodate,
	title = {Building a {PoC} of {Segment} {Routing} at {100G} {Using} {FPGA} {Smart} {NIC} and {P4} {Language}},
	language = {en},
	author = {Kaštovský, Petr},
	file = {Kaštovský - Building a PoC of Segment Routing at 100G Using FP.pdf:C\:\\Users\\Yann\\Zotero\\storage\\QH6P9HH7\\Kaštovský - Building a PoC of Segment Routing at 100G Using FP.pdf:application/pdf},
}

@inproceedings{yazdinejad_p4_2018,
	title = {P4 to {SDNet}: {Automatic} {Generation} of an {Efficient} {Protocol}-{Independent} {Packet} {Parser} on {Reconfigurable} {Hardware}},
	shorttitle = {P4 to {SDNet}},
	doi = {10.1109/ICCKE.2018.8566590},
	abstract = {Nowadays network managers look for ways to change the design and management of networks that can make decisions on the control plane. Future switches should be able to support the new features and flexibility required for parsing and processing packets. One of the critical components of switches is the packet parser that processes the headers of the packets to be able to decide on the incoming packets. Here the data plane, and particularly packet parser in OpenFlow switches, which should have the flexibility and programmability to support the new requirements and OpenFlow multiple versions, are focused. Designed here is an architecture that unlike the static network equipments, it has the flexibility and programmability in the data plane network, especially the SDN network, and supports the parsing and processing of specific packets. To describe this architecture, a high-level P4 language is used to implement it on a reconfigurable hardware (i.e., FPGA). After automatic generating the protocol-independent Packet parser architecture on the Virtex-7, it is compiled to firmware by Xilinx SDNet, and ultimately an FPGA Platform is implemented. It has fewer consumption resources and it is more efficient in terms of throughput and processing speed in comparison with other architectures.},
	booktitle = {2018 8th {International} {Conference} on {Computer} and {Knowledge} {Engineering} ({ICCKE})},
	author = {Yazdinejad, Abbas and Bohlooli, Ali and Jamshidi, Kamal},
	month = oct,
	year = {2018},
	note = {ISSN: 2375-1304},
	keywords = {Computer architecture, Field programmable gate arrays, Pipelines, Protocols, Hardware, P4, Program processors, Data Plane, Delays, OpenFlow Switch, Packet Parser, Reconfigurable Hardware, SDNet},
	pages = {159--164},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Yann\\Zotero\\storage\\3T8BHV47\\8566590.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\MDX65UFM\\Yazdinejad et al. - 2018 - P4 to SDNet Automatic Generation of an Efficient .pdf:application/pdf},
}

@article{amd_xilinx_inc_vitis_2022,
	title = {Vitis {Networking} {P4} {User} {Guide}},
	language = {en},
	urldate = {2023-02-21},
	author = {{AMD Xilinx Inc.}},
	year = {2022},
	file = {2022 - Vitis Networking P4 User Guide.pdf:C\:\\Users\\Yann\\Zotero\\storage\\UF8EUF9Y\\2022 - Vitis Networking P4 User Guide.pdf:application/pdf},
}

@misc{noauthor_intelligent_nodate,
	title = {Intelligent fabric processors - {Tofino} - {Switch} to intelligence},
	url = {https://www.intel.com/content/www/ca/en/products/network-io/programmable-ethernet-switch/tofino-3-product-brochure.html},
	abstract = {Upgrade from fixed-function Ethernet switches to Intel Tofino P4 programmable intelligent fabric processors.},
	language = {en},
	urldate = {2023-02-22},
	journal = {Intel},
	file = {Intelligent fabric processors - Tofino - Switch to.pdf:C\:\\Users\\Yann\\Zotero\\storage\\LQXMBPHI\\Intelligent fabric processors - Tofino - Switch to.pdf:application/pdf;Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\X7M6V2L5\\tofino-3-product-brochure.html:text/html},
}

@inproceedings{xing_vision_2021,
	address = {New York, NY, USA},
	series = {{HotNets} '21},
	title = {A {Vision} for {Runtime} {Programmable} {Networks}},
	isbn = {978-1-4503-9087-3},
	url = {https://doi.org/10.1145/3484266.3487377},
	doi = {10.1145/3484266.3487377},
	abstract = {Our community has made significant progress in developing programmable network infrastructure, starting from the control plane and expanding to the data plane. As a latest trend, network devices are becoming runtime programmable while serving live traffic. This allows for reprogramming of individual device programs at fine-grained timescales to add or remove network functions. Many applications and services, however, need control over a combination of devices, including end host stacks, NICs, and switches, to accomplish their goals. We lay out our vision for runtime programmable networks, building upon device-level features to provide live, network-wide, runtime reprogramming. A whole-stack approach is needed with new programming models, compiler support, and network management abstractions. We outline a research agenda as a call to arms to the community.},
	urldate = {2023-02-24},
	booktitle = {Proceedings of the {Twentieth} {ACM} {Workshop} on {Hot} {Topics} in {Networks}},
	publisher = {Association for Computing Machinery},
	author = {Xing, Jiarong and Qiu, Yiming and Hsu, Kuo-Feng and Liu, Hongyi and Kadosh, Matty and Lo, Alan and Akella, Aditya and Anderson, Thomas and Krishnamurthy, Arvind and Ng, T. S. Eugene and Chen, Ang},
	month = nov,
	year = {2021},
	keywords = {Programmable networks},
	pages = {91--98},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\BPZ4K4DV\\Xing et al. - 2021 - A Vision for Runtime Programmable Networks.pdf:application/pdf},
}

@misc{amd_xilinx_inc_introduction_2022,
	title = {Introduction • {Getting} {Started} with {Alveo} {Data} {Center} {Accelerator} {Cards} {User} {Guide} ({UG1301}) • {Reader} • {Documentation} {Portal}},
	url = {https://docs.xilinx.com/r/en-US/ug1301-getting-started-guide-alveo-accelerator-cards/Introduction},
	urldate = {2023-02-24},
	author = {{AMD Xilinx Inc.}},
	month = dec,
	year = {2022},
	keywords = {Lu},
	file = {2022 - Getting Started with Alveo Data Center Accelerator.pdf:C\:\\Users\\Yann\\Zotero\\storage\\WAKNJ4KT\\2022 - Getting Started with Alveo Data Center Accelerator.pdf:application/pdf;Introduction • Getting Started with Alveo Data Center Accelerator Cards User Guide (UG1301) • Reader • Documentation Portal:C\:\\Users\\Yann\\Zotero\\storage\\CLADNTFX\\Introduction.html:text/html},
}

@article{noauthor_getting_2022,
	title = {Getting {Started} with {Alveo} {Data} {Center} {Accelerator} {Cards}},
	language = {en},
	year = {2022},
	keywords = {Lu},
}

@inproceedings{xing_runtime_2022,
	title = {Runtime {Programmable} {Switches}},
	isbn = {978-1-939133-27-4},
	url = {https://www.usenix.org/conference/nsdi22/presentation/xing},
	language = {en},
	urldate = {2023-02-27},
	author = {Xing, Jiarong and Hsu, Kuo-Feng and Kadosh, Matty and Lo, Alan and Piasetzky, Yonatan and Krishnamurthy, Arvind and Chen, Ang},
	year = {2022},
	pages = {651--665},
	file = {Full Text PDF:C\:\\Users\\Yann\\Zotero\\storage\\A6ZIH8AC\\Xing et al. - 2022 - Runtime Programmable Switches.pdf:application/pdf},
}

@misc{noauthor_content_nodate,
	title = {Content {Addressable} {Memory} ({CAM})},
	url = {https://www.xilinx.com/products/intellectual-property/ef-di-cam.html},
	language = {en},
	urldate = {2023-03-01},
	journal = {Xilinx},
	keywords = {Lu},
	file = {Snapshot:C\:\\Users\\Yann\\Zotero\\storage\\Q5F9FIPV\\ef-di-cam.html:text/html},
}
